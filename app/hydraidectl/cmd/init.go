package cmd

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"

	"github.com/hydraide/hydraide/app/hydraidectl/cmd/utils"
	"github.com/hydraide/hydraide/app/hydraidectl/cmd/utils/certificate"
	"github.com/spf13/cobra"
)

type CertConfig struct {
	CN  string
	DNS []string
	IP  []string
}

type EnvConfig struct {
	LogLevel               string
	LogTimeFormat          string
	SystemResourceLogging  bool
	GraylogEnabled         bool
	GraylogServer          string
	GraylogServiceName     string
	GRPCMaxMessageSize     int64
	GRPCServerErrorLogging bool
	CloseAfterIdle         int
	WriteInterval          int
	FileSize               int
	HydraidePort           string
	HydraideBasePath       string
	HealthCheckPort        string
}

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Run the quick install wizard",
	Run: func(cmd *cobra.Command, args []string) {

		reader := bufio.NewReader(os.Stdin)

		fmt.Println("üöÄ Starting HydrAIDE install wizard...\n")

		var cert CertConfig
		var envCfg EnvConfig

		// Certificate CN ‚Äì default = localhost
		fmt.Println("üåê TLS Certificate Setup")
		fmt.Println("üîñ Common Name (CN) is the main name assigned to the certificate.")
		fmt.Println("It usually identifies your company or internal system.")
		fmt.Print("CN (e.g. yourcompany, api.hydraide.local) (default: hydraide): ")
		cnInput, _ := reader.ReadString('\n')
		cert.CN = strings.TrimSpace(cnInput)
		if cert.CN == "" {
			cert.CN = "hydraide"
		}

		// localhost hozz√°ad√°sa
		cert.DNS = append(cert.DNS, "localhost")
		cert.IP = append(cert.IP, "127.0.0.1")

		// IP-k:bels≈ë s k√ºls≈ë c√≠mek
		fmt.Println("\nüåê Add additional IP addresses to the certificate?")
		fmt.Println("By default, '127.0.0.1' is included for localhost access.")
		fmt.Println()
		fmt.Println("Now, list any other IP addresses where clients will access the HydrAIDE server.")
		fmt.Println("For example, if the HydrAIDE container is reachable at 192.168.106.100:4900, include that IP.")
		fmt.Println("These IPs must match the address used in the TLS connection, or it will fail.")
		fmt.Print("Do you want to add other IPs besides 127.0.0.1? (y/n): ")

		ans, _ := reader.ReadString('\n')
		if strings.ToLower(strings.TrimSpace(ans)) == "y" {
			fmt.Print("Enter IPs (comma-separated, e.g. 192.168.1.5,10.0.0.12): ")
			ipInput, _ := reader.ReadString('\n')
			ips := strings.Split(strings.TrimSpace(ipInput), ",")
			for _, ip := range ips {
				ip = strings.TrimSpace(ip)
				if ip != "" {
					cert.IP = append(cert.IP, ip)
				}
			}
		}

		fmt.Println("\nüåê Will clients connect via a domain name (FQDN)?")
		fmt.Println("This includes public domains (e.g. api.example.com) or internal DNS (e.g. hydraide.lan).")
		fmt.Println("To ensure secure TLS connections, you must list any domains that clients will use.")
		fmt.Print("Add domain names to the certificate? (y/n): ")
		ans, _ = reader.ReadString('\n')
		if strings.ToLower(strings.TrimSpace(ans)) == "y" {
			fmt.Print("Enter domain names (comma-separated, e.g. api.example.com,hydraide.local): ")
			dnsInput, _ := reader.ReadString('\n')
			domains := strings.Split(strings.TrimSpace(dnsInput), ",")
			for _, d := range domains {
				d = strings.TrimSpace(d)
				if d != "" {
					cert.DNS = append(cert.DNS, d)
				}
			}
		}

		fmt.Println("\nüîå Port Configuration")
		fmt.Println("This is the external port on your host machine that will map to the HydrAIDE container.")
		fmt.Println("Clients will use this port to communicate with the HydrAIDE server.")
		fmt.Print("Which port should HydrAIDE listen on? (default: 4900): ")
		envCfg.HydraidePort, _ = reader.ReadString('\n')
		envCfg.HydraidePort = strings.TrimSpace(envCfg.HydraidePort)
		if envCfg.HydraidePort == "" {
			envCfg.HydraidePort = "4900"
		}

		fmt.Println("\nüìÅ Base Path for HydrAIDE")
		fmt.Println("This is the main directory where HydrAIDE will store its core files.")
		fmt.Print("Base path (default: /mnt/hydraide): ")
		envCfg.HydraideBasePath, _ = reader.ReadString('\n')
		envCfg.HydraideBasePath = strings.TrimSpace(envCfg.HydraideBasePath)
		if envCfg.HydraideBasePath == "" {
			envCfg.HydraideBasePath = "/mnt/hydraide"
		}

		fmt.Println("\nüìù Logging Configuration")

		// LOG_LEVEL
		fmt.Println("üîç Log Level: Controls the amount of detail in system logs")
		fmt.Println("   Options: trace, debug, info, warn, error, fatal, panic")
		fmt.Println("   Recommended: 'info' for production, 'debug' for troubleshooting")
		fmt.Print("Log level [default: info]: ")
		logLevel, _ := reader.ReadString('\n')
		logLevel = strings.TrimSpace(logLevel)
		if logLevel == "" {
			logLevel = "info"
		}
		envCfg.LogLevel = logLevel

		// SYSTEM_RESOURCE_LOGGING
		fmt.Println("\nüíª System Resource Monitoring")
		fmt.Println("   Enables periodic logging of CPU, memory, and disk usage")
		fmt.Println("   Useful for performance monitoring but adds log entries")
		fmt.Print("Enable system resource logging? (y/n) [default: n]: ")
		resLogInput, _ := reader.ReadString('\n')
		resLogInput = strings.ToLower(strings.TrimSpace(resLogInput))
		envCfg.SystemResourceLogging = (resLogInput == "y" || resLogInput == "yes")

		// GRAYLOG CONFIGURATION
		fmt.Println("\nüìä Graylog Integration")
		fmt.Print("Enable Graylog centralized logging? (y/n) [default: n]: ")
		graylogInput, _ := reader.ReadString('\n')
		graylogInput = strings.ToLower(strings.TrimSpace(graylogInput))
		envCfg.GraylogEnabled = (graylogInput == "y" || graylogInput == "yes")

		if envCfg.GraylogEnabled {
			fmt.Println("üåê Graylog Server Address")
			fmt.Println("   Format: host:port (e.g., graylog.example.com:5140)")
			fmt.Print("Graylog server address: ")
			graylogServer, _ := reader.ReadString('\n')
			envCfg.GraylogServer = strings.TrimSpace(graylogServer)

			fmt.Println("\nüìõ Graylog Service Identifier")
			fmt.Println("   Unique name for this HydrAIDE instance in Graylog")
			fmt.Print("Service name [default: hydraide-prod]: ")
			serviceName, _ := reader.ReadString('\n')
			serviceName = strings.TrimSpace(serviceName)
			if serviceName == "" {
				serviceName = "hydraide-prod"
			}
			envCfg.GraylogServiceName = serviceName
		}

		// GRPC CONFIGURATION
		fmt.Println("\nüì° gRPC Settings")

		// GRPC_MAX_MESSAGE_SIZE
		fmt.Println("üìè Max Message Size: Maximum size for gRPC messages (bytes)")
		fmt.Println("   Default: 5GB (5368709120) - Adjust for large data transfers")
		fmt.Print("Max message size [default: 5368709120]: ")
		maxSizeInput, _ := reader.ReadString('\n')
		maxSizeInput = strings.TrimSpace(maxSizeInput)
		if maxSizeInput == "" {
			envCfg.GRPCMaxMessageSize = 5368709120
		} else {
			if size, err := strconv.ParseInt(maxSizeInput, 10, 64); err == nil {
				envCfg.GRPCMaxMessageSize = size
			} else {
				fmt.Printf("‚ö†Ô∏è Invalid number, using default 5GB. Error: %v\n", err)
				envCfg.GRPCMaxMessageSize = 5368709120
			}
		}

		// GRPC_SERVER_ERROR_LOGGING
		fmt.Println("\n‚ö†Ô∏è gRPC Error Logging")
		fmt.Println("   Logs detailed errors from gRPC server operations")
		fmt.Print("Enable gRPC error logging? (y/n) [default: y]: ")
		grpcErrInput, _ := reader.ReadString('\n')
		grpcErrInput = strings.ToLower(strings.TrimSpace(grpcErrInput))
		envCfg.GRPCServerErrorLogging = (grpcErrInput != "n" && grpcErrInput != "no")

		// SWAMP STORAGE SETTINGS
		fmt.Println("\nüèûÔ∏è Swamp Storage Configuration")

		// CLOSE_AFTER_IDLE
		fmt.Println("‚è±Ô∏è Auto-Close Idle Swamps")
		fmt.Println("   Time in seconds before idle Swamps are automatically closed")
		fmt.Print("Idle timeout [default: 10]: ")
		idleInput, _ := reader.ReadString('\n')
		idleInput = strings.TrimSpace(idleInput)
		if idleInput == "" {
			envCfg.CloseAfterIdle = 10
		} else {
			if idle, err := strconv.Atoi(idleInput); err == nil {
				envCfg.CloseAfterIdle = idle
			} else {
				fmt.Printf("‚ö†Ô∏è Invalid number, using default 10s. Error: %v\n", err)
				envCfg.CloseAfterIdle = 10
			}
		}

		// WRITE_INTERVAL
		fmt.Println("\n‚è±Ô∏è Disk Write Frequency")
		fmt.Println("   How often (in seconds) Swamp data is written to disk")
		fmt.Print("Write interval [default: 5]: ")
		writeInput, _ := reader.ReadString('\n')
		writeInput = strings.TrimSpace(writeInput)
		if writeInput == "" {
			envCfg.WriteInterval = 5
		} else {
			if interval, err := strconv.Atoi(writeInput); err == nil {
				envCfg.WriteInterval = interval
			} else {
				fmt.Printf("‚ö†Ô∏è Invalid number, using default 5s. Error: %v\n", err)
				envCfg.WriteInterval = 5
			}
		}

		// FILE_SIZE
		fmt.Println("\nüì¶ Storage Fragment Size")
		fmt.Println("   Size in bytes for Swamp storage fragments (default: 8KB)")
		fmt.Print("File fragment size [default: 8192]: ")
		sizeInput, _ := reader.ReadString('\n')
		sizeInput = strings.TrimSpace(sizeInput)
		if sizeInput == "" {
			envCfg.FileSize = 8192
		} else {
			if size, err := strconv.Atoi(sizeInput); err == nil {
				envCfg.FileSize = size
			} else {
				fmt.Printf("‚ö†Ô∏è Invalid number, using default 8192 bytes. Error: %v\n", err)
				envCfg.FileSize = 8192
			}
		}

		// HEALTH CHECK PORT
		fmt.Println("\n‚ù§Ô∏è‚Äçü©π Health Check Endpoint")
		fmt.Println("   Separate port for health checks and monitoring")
		fmt.Print("Health check port [default: 4901]: ")
		healthPort, _ := reader.ReadString('\n')
		healthPort = strings.TrimSpace(healthPort)
		if healthPort == "" {
			healthPort = "4901"
		}
		envCfg.HealthCheckPort = healthPort

		// ======================
		// CONFIGURATION SUMMARY
		// ======================
		fmt.Println("\nüîß Configuration Summary:")
		fmt.Println("=== NETWORK ===")
		fmt.Println("  ‚Ä¢ CN:         ", cert.CN)
		fmt.Println("  ‚Ä¢ DNS SANs:   ", strings.Join(cert.DNS, ", "))
		fmt.Println("  ‚Ä¢ IP SANs:    ", strings.Join(cert.IP, ", "))
		fmt.Println("  ‚Ä¢ Main Port:  ", envCfg.HydraidePort)
		fmt.Println("  ‚Ä¢ Health Port:", envCfg.HealthCheckPort)

		fmt.Println("\n=== LOGGING ===")
		fmt.Println("  ‚Ä¢ Log Level:       ", envCfg.LogLevel)
		fmt.Println("  ‚Ä¢ Resource Logging:", envCfg.SystemResourceLogging)
		fmt.Println("  ‚Ä¢ Graylog Enabled: ", envCfg.GraylogEnabled)
		if envCfg.GraylogEnabled {
			fmt.Println("      ‚Ä¢ Server:     ", envCfg.GraylogServer)
			fmt.Println("      ‚Ä¢ Service:    ", envCfg.GraylogServiceName)
		}

		fmt.Println("\n=== gRPC ===")
		fmt.Printf("  ‚Ä¢ Max Message Size: %.2f GB\n", float64(envCfg.GRPCMaxMessageSize)/1024/1024/1024)
		fmt.Println("  ‚Ä¢ Error Logging:   ", envCfg.GRPCServerErrorLogging)

		fmt.Println("\n=== STORAGE ===")
		fmt.Println("  ‚Ä¢ Close After Idle: ", envCfg.CloseAfterIdle, "seconds")
		fmt.Println("  ‚Ä¢ Write Interval:   ", envCfg.WriteInterval, "seconds")
		fmt.Printf("  ‚Ä¢ File Fragment Size: %d bytes (%.2f KB)\n",
			envCfg.FileSize, float64(envCfg.FileSize)/1024)

		fmt.Println("\n=== PATHS ===")
		fmt.Println("  ‚Ä¢ Base Path:  ", envCfg.HydraideBasePath)

		// Confirmation
		fmt.Print("\n‚úÖ Proceed with installation? (y/n): ")
		confirm, _ := reader.ReadString('\n')
		confirm = strings.ToLower(strings.TrimSpace(confirm))
		if confirm != "y" && confirm != "yes" {
			fmt.Println("üö´ Installation cancelled.")
			return
		}

		fmt.Println("\n‚úÖ Starting installation...")

		// todo: start the instance installation process

		// - todo: create the necessary directories

		folders := []string{"certificate", "data", "settings"}
		fmt.Println("üìÇ Creating application folders...", folders)
		err := utils.CreateFolders(envCfg.HydraideBasePath, folders)
		if err != nil {
			fmt.Println("‚ùå Error creating application folders:", err)
			return
		}
		// double check if Directory created or not
		if verbose, err := utils.CheckDirectoryExists(envCfg.HydraideBasePath, folders); err != nil {
			fmt.Println("‚ùå Error checking directories:", err)
			return
		} else {
			fmt.Println(verbose)
		}

		// - todo: generate the TLS certificate
		fmt.Println("üîí Generating TLS certificate...")
		certGen := certificate.New(cert.CN, cert.DNS, cert.IP)
		if err = certGen.Generate(); err != nil {
			fmt.Println("‚ùå Error generating TLS certificate:", err)
			return
		}
		fmt.Println("‚úÖ TLS certificate generated successfully.")
		clientCRT, serverCRT, serverKEY := certGen.Files()
		fmt.Println("  ‚Ä¢ Client CRT: ", clientCRT)
		fmt.Println("  ‚Ä¢ Server CRT: ", serverCRT)
		fmt.Println("  ‚Ä¢ Server KEY: ", serverKEY)

		// - todo: copy the server and client TLS certificate to the certificate directory

		fmt.Println("üìÇ Copying TLS certificates to the certificate directory...")
		fmt.Printf("  ‚Ä¢ Client CRT: From %s  to  %s \n", clientCRT, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(clientCRT)))
		utils.MoveFile(clientCRT, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(clientCRT)))
		fmt.Printf("  ‚Ä¢ Server CRT: From %s  to  %s \n", serverCRT, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(serverCRT)))
		utils.MoveFile(serverCRT, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(serverCRT)))
		fmt.Printf("  ‚Ä¢ Server KEY: From %s  to  %s \n", serverKEY, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(serverKEY)))
		utils.MoveFile(serverKEY, filepath.Join(envCfg.HydraideBasePath, "certificate", filepath.Base(serverKEY)))

		fmt.Println("‚úÖ TLS certificates copied successfully.")

		// - todo: create the .env file (based on the .env_sample) to base path and fill in the values
		// ===========================
		// CREATE .ENV FILE
		// ===========================
		currentDir, err := os.Getwd()
		if err != nil {
			fmt.Println("‚ùå Error getting current directory:", err)
			return
		}

		envPath := filepath.Join(currentDir, ".env")

		// Check if .env exists and warn user
		if _, err := os.Stat(envPath); err == nil {
			fmt.Printf("\n‚ö†Ô∏è  Found existing .env file at: %s\n", envPath)

			// Show current content
			existingContent, err := os.ReadFile(envPath)
			if err == nil {
				fmt.Println("\nüìÑ Current .env content:")
				fmt.Println(strings.Repeat("-", 40))
				fmt.Println(string(existingContent))
				fmt.Println(strings.Repeat("-", 40))
			}

			// Confirm overwrite
			fmt.Print("\n‚ùì Do you want to overwrite this file? (y/n) [default: y]: ")
			overwrite, _ := reader.ReadString('\n')
			overwrite = strings.ToLower(strings.TrimSpace(overwrite))

			if overwrite == "n" || overwrite == "no" {
				fmt.Println("‚ÑπÔ∏è  Keeping existing .env file")
				fmt.Println("‚úÖ Proceeding with installation using existing configuration")
				return
			}

			fmt.Println("üîÑ Overwriting existing .env file...")
		}

		// Create or truncate the .env file
		envFile, err := os.Create(envPath) // This automatically clears the file if it exists
		if err != nil {
			fmt.Println("‚ùå Error creating .env file:", err)
			return
		}
		defer envFile.Close()

		// Write all environment variables
		writer := bufio.NewWriter(envFile)
		writeEnv := func(key, value string) {
			_, _ = writer.WriteString(fmt.Sprintf("%s=%s\n", key, value))
		}

		// Write header comment
		_, _ = writer.WriteString("# HydrAIDE Configuration\n")
		_, _ = writer.WriteString("# Generated automatically - DO NOT EDIT MANUALLY\n\n")

		// Write all configuration values
		writeEnv("LOG_LEVEL", envCfg.LogLevel)
		writeEnv("LOG_TIME_FORMAT", "2006-01-02T15:04:05Z07:00")
		writeEnv("SYSTEM_RESOURCE_LOGGING", strconv.FormatBool(envCfg.SystemResourceLogging))
		writeEnv("GRAYLOG_ENABLED", strconv.FormatBool(envCfg.GraylogEnabled))
		writeEnv("GRAYLOG_SERVER", envCfg.GraylogServer)
		writeEnv("GRAYLOG_SERVICE_NAME", envCfg.GraylogServiceName)
		writeEnv("GRPC_MAX_MESSAGE_SIZE", strconv.FormatInt(envCfg.GRPCMaxMessageSize, 10))
		writeEnv("GRPC_SERVER_ERROR_LOGGING", strconv.FormatBool(envCfg.GRPCServerErrorLogging))
		writeEnv("HYDRAIDE_ROOT_PATH", envCfg.HydraideBasePath)
		writeEnv("HYDRAIDE_SERVER_PORT", envCfg.HydraidePort)
		writeEnv("HYDRAIDE_DEFAULT_CLOSE_AFTER_IDLE", strconv.Itoa(envCfg.CloseAfterIdle))
		writeEnv("HYDRAIDE_DEFAULT_WRITE_INTERVAL", strconv.Itoa(envCfg.WriteInterval))
		writeEnv("HYDRAIDE_DEFAULT_FILE_SIZE", strconv.Itoa(envCfg.FileSize))
		writeEnv("HEALTH_CHECK_PORT", envCfg.HealthCheckPort)

		// Add final newline and flush
		_, _ = writer.WriteString("\n")
		if err := writer.Flush(); err != nil {
			fmt.Println("‚ùå Error writing to .env file:", err)
			return
		}

		fmt.Println("‚úÖ .env file created/updated successfully at:", envPath)

		// - todo: download the latest binary (or the tagged one) from the github releases
		// - todo: create a service file based on the user's operating system
		// - todo: start the service

	},
}

func init() {
	rootCmd.AddCommand(initCmd)
}

func defaultInstallPath() string {
	home, _ := os.UserHomeDir()
	switch runtime.GOOS {
	case "windows":
		return filepath.Join(os.Getenv("APPDATA"), "HydrAIDE", "bin")
	case "darwin":
		return filepath.Join(home, "Library", "Application Support", "HydrAIDE", "bin")
	default:
		return filepath.Join(home, ".hydraide", "bin")
	}
}
