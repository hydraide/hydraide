// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: proto/hydraide.proto

package hydraidepbgo

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	HydraideService_Heartbeat_FullMethodName               = "/hydraidepbgo.HydraideService/Heartbeat"
	HydraideService_Lock_FullMethodName                    = "/hydraidepbgo.HydraideService/Lock"
	HydraideService_Unlock_FullMethodName                  = "/hydraidepbgo.HydraideService/Unlock"
	HydraideService_RegisterSwamp_FullMethodName           = "/hydraidepbgo.HydraideService/RegisterSwamp"
	HydraideService_DeRegisterSwamp_FullMethodName         = "/hydraidepbgo.HydraideService/DeRegisterSwamp"
	HydraideService_Set_FullMethodName                     = "/hydraidepbgo.HydraideService/Set"
	HydraideService_Get_FullMethodName                     = "/hydraidepbgo.HydraideService/Get"
	HydraideService_GetAll_FullMethodName                  = "/hydraidepbgo.HydraideService/GetAll"
	HydraideService_GetByIndex_FullMethodName              = "/hydraidepbgo.HydraideService/GetByIndex"
	HydraideService_GetByKeys_FullMethodName               = "/hydraidepbgo.HydraideService/GetByKeys"
	HydraideService_ShiftExpiredTreasures_FullMethodName   = "/hydraidepbgo.HydraideService/ShiftExpiredTreasures"
	HydraideService_Destroy_FullMethodName                 = "/hydraidepbgo.HydraideService/Destroy"
	HydraideService_Delete_FullMethodName                  = "/hydraidepbgo.HydraideService/Delete"
	HydraideService_Count_FullMethodName                   = "/hydraidepbgo.HydraideService/Count"
	HydraideService_IsSwampExist_FullMethodName            = "/hydraidepbgo.HydraideService/IsSwampExist"
	HydraideService_IsKeyExist_FullMethodName              = "/hydraidepbgo.HydraideService/IsKeyExist"
	HydraideService_SubscribeToEvents_FullMethodName       = "/hydraidepbgo.HydraideService/SubscribeToEvents"
	HydraideService_SubscribeToInfo_FullMethodName         = "/hydraidepbgo.HydraideService/SubscribeToInfo"
	HydraideService_Uint32SlicePush_FullMethodName         = "/hydraidepbgo.HydraideService/Uint32SlicePush"
	HydraideService_Uint32SliceDelete_FullMethodName       = "/hydraidepbgo.HydraideService/Uint32SliceDelete"
	HydraideService_Uint32SliceSize_FullMethodName         = "/hydraidepbgo.HydraideService/Uint32SliceSize"
	HydraideService_Uint32SliceIsValueExist_FullMethodName = "/hydraidepbgo.HydraideService/Uint32SliceIsValueExist"
	HydraideService_IncrementInt8_FullMethodName           = "/hydraidepbgo.HydraideService/IncrementInt8"
	HydraideService_IncrementInt16_FullMethodName          = "/hydraidepbgo.HydraideService/IncrementInt16"
	HydraideService_IncrementInt32_FullMethodName          = "/hydraidepbgo.HydraideService/IncrementInt32"
	HydraideService_IncrementInt64_FullMethodName          = "/hydraidepbgo.HydraideService/IncrementInt64"
	HydraideService_IncrementUint8_FullMethodName          = "/hydraidepbgo.HydraideService/IncrementUint8"
	HydraideService_IncrementUint16_FullMethodName         = "/hydraidepbgo.HydraideService/IncrementUint16"
	HydraideService_IncrementUint32_FullMethodName         = "/hydraidepbgo.HydraideService/IncrementUint32"
	HydraideService_IncrementUint64_FullMethodName         = "/hydraidepbgo.HydraideService/IncrementUint64"
	HydraideService_IncrementFloat32_FullMethodName        = "/hydraidepbgo.HydraideService/IncrementFloat32"
	HydraideService_IncrementFloat64_FullMethodName        = "/hydraidepbgo.HydraideService/IncrementFloat64"
)

// HydraideServiceClient is the client API for HydraideService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HydraideServiceClient interface {
	// Heartbeat checks if the HydrAIDE server is alive.
	// The client sends a Ping and expects a Pong response.
	Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error)
	// Lock allows you to create a mutex-like lock based on a given key.
	// It queues all lock requests for the same key and only returns once the lock is granted.
	// This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.
	//
	// ‚ö†Ô∏è Note: Locking is logical only ‚Äî it does not block the actual data access unless your logic respects the lock.
	// You must explicitly use the Lock/Unlock sequence around relevant operations.
	//
	// Required: TTL must be set (timeout in milliseconds).
	// If the lock cannot be acquired within this TTL, the call returns an error.
	// If a lock is granted, a LockID is returned, which must be passed to Unlock.
	Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error)
	// Unlock releases the previously granted lock based on the key and LockID.
	// If the LockID is invalid or does not match an existing lock, the call fails.
	//
	// It is crucial to always unlock your locks to avoid deadlocks.
	// If the TTL expires, the lock is automatically released.
	Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error)
	// RegisterSwamp registers a new swamp pattern in the HydrAIDE system.
	// A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.
	//
	// You can configure:
	// - Whether the swamp lives in memory or on disk
	// - How long it should stay alive without access (CloseAfterIdle)
	// - How frequently it should flush to disk (WriteInterval)
	// - Maximum file size per chunk (MaxFileSize)
	//
	// Use this to define behavior per collection before inserting data.
	RegisterSwamp(ctx context.Context, in *RegisterSwampRequest, opts ...grpc.CallOption) (*RegisterSwampResponse, error)
	// DeRegisterSwamp removes a previously registered swamp pattern.
	// This does not delete the swamp data ‚Äî it only removes its active configuration.
	//
	// Use this to clean up unused swamp definitions.
	DeRegisterSwamp(ctx context.Context, in *DeRegisterSwampRequest, opts ...grpc.CallOption) (*DeRegisterSwampResponse, error)
	// Set inserts or updates one or more key-value pairs into one or more swamps.
	// You can control the behavior using two flags:
	// - CreateIfNotExist: If false, the swamp/key must already exist (update only).
	// - Overwrite: If false, the existing value will not be overwritten.
	//
	// ‚ö†Ô∏è Each KeyValuePair supports multiple data types:
	// - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
	// - Floating point types: float32, float64
	// - Booleans, strings, bytes, and even slices (e.g., uint32[])
	//
	// üí° HydrAIDE stores the value using its **actual underlying type** without upcasting,
	// which means no wasted memory or disk space ‚Äì you only store what you really need.
	//
	// You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.
	//
	// ‚úÖ Supports multiple swamps in a single request for batch operations.
	//
	// üîî Realtime: Any inserted or updated treasures will trigger an immediate
	// event to all active subscribers via the SubscribeToEvents stream.
	//
	// This makes HydrAIDE suitable for:
	// - Real-time dashboards
	// - Cache invalidation listeners
	// - Live analytics feeds
	Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error)
	// Get retrieves one or more key-value pairs by key from one or more swamps.
	// You must specify the swamp name and the list of keys per swamp.
	//
	// Each response includes the key, value, and metadata fields (timestamps, creators).
	// This is a type-safe, structured read ‚Äì no JSON parsing needed on the client side.
	Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error)
	// GetAll retrieves **all** key-value pairs from a given swamp.
	//
	// This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
	// Not recommended for large datasets unless scoped and filtered client-side.
	GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (*GetAllResponse, error)
	// GetByIndex allows indexed reads based on fields like:
	// - ExpirationTime
	// - CreationTime
	// - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)
	//
	// You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
	// This makes the HydrAIDE engine powerful for search, feed, and queue-like structures.
	//
	// ‚ö†Ô∏è HydrAIDE creates index structures on-demand in memory when this method is called.
	// These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
	// This means indexing is stateless, fast, and leaves no storage overhead.
	//
	// You do not need to pre-define indexes. Simply call this method with the right IndexType.
	GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error)
	// GetByKeys allows efficient multi-key read operations from a single Swamp in one request.
	//
	// This feature is called **CatalogReadBatch**, and it allows clients to pass a list of keys
	// and receive all existing Treasures in a single response, rather than calling `Get()` multiple times.
	//
	// The goal is to reduce roundtrip latency and network overhead when fetching many records by known keys
	// (for example, when using secondary indexes).
	//
	// ‚ö†Ô∏è Behavioral notes:
	// - The request can contain any number of keys (bounded by server configuration).
	// - The response may be unordered ‚Äî the server does not need to preserve key order.
	// - Missing keys are silently ignored (they simply don't appear in the response).
	// - If none of the keys exist, the response should be empty (not an error).
	// - Errors (connection, invalid argument, etc.) follow the same error semantics as `GetByIndex`.
	//
	// üí° Why this is needed:
	// When using secondary indexes, HydrAIDE users often have to read dozens or hundreds of Treasures by known keys.
	// Currently, this requires multiple `CatalogRead()` calls (one per key), causing N+1 network roundtrips.
	// With `GetByKeys`, the same can be done with a *single RPC call*, improving throughput by 30‚Äì50√ó
	// and reducing latency dramatically.
	GetByKeys(ctx context.Context, in *GetByKeysRequest, opts ...grpc.CallOption) (*GetByKeysResponse, error)
	// ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.
	//
	// This method is ideal for implementing task queues, time-based processing systems,
	// or scheduled cleanup mechanisms where only expired items should be processed.
	//
	// You can control how many items to retrieve at once using the `HowMany` parameter:
	// - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
	// - If `HowMany` > 0, only that many expired entries will be returned in the response
	//
	// ‚ö†Ô∏è Important: This method is destructive ‚Äì the returned items will be permanently removed from the swamp.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this for building things like:
	// - Delayed jobs
	// - Expiring caches
	// - Scheduled triggers (e.g. publish-after-expiry)
	ShiftExpiredTreasures(ctx context.Context, in *ShiftExpiredTreasuresRequest, opts ...grpc.CallOption) (*ShiftExpiredTreasuresResponse, error)
	// Destroy permanently deletes the entire swamp and all its treasures.
	//
	// This removes all data associated with the given swamp, including metadata, indexes, and chunks.
	//
	// ‚ö†Ô∏è Warning: This operation is irreversible. All data will be lost.
	// Use only when you're absolutely sure the swamp is no longer needed.
	//
	// Typical use cases:
	// - Cleanup after tests or temporary data
	// - User data deletion requests
	// - Full environment reset
	Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error)
	// Delete removes one or more treasures (key-value pairs) from the specified swamp.
	//
	// This is a precise, non-destructive swamp-level operation.
	// You must provide the swamp name and the list of keys to delete.
	//
	// ‚úÖ Supports batch deletion across multiple swamps in a single request.
	// Each swamp and its deleted keys will be included in the response.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this to:
	// - Manually remove outdated or invalid entries
	// - Implement "soft delete" logic (client-side)
	// - Perform targeted cleanup operations
	Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error)
	// Count returns the number of treasures in one or more specified swamps.
	//
	// You provide a list of swamp names, and for each swamp HydrAIDE returns:
	// - Whether the swamp exists
	// - How many elements (treasures) are currently stored in it
	//
	// ‚úÖ This is useful for:
	// - Dashboard metrics and monitoring
	// - Queue size estimation
	// - Expiry-aware cleanup or batch logic
	//
	// üí° The count is calculated instantly from the swamp‚Äôs current state,
	// with no need for full traversal or manual iteration.
	//
	// Can be used across multiple swamps in a single request.
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error)
	// IsSwampExist checks if the specified swamp exists in the given sanctuary.
	//
	// This method does not create or modify anything ‚Äì it only verifies existence.
	// Use it to validate swamp names before writing, migrating, or deleting.
	//
	// Typical use cases:
	// - Pre-checks before Set/Delete operations
	// - UI/UX logic (e.g. show/hide a swamp)
	// - Schema validation before batch processing
	//
	// üí° Note: Swamp existence does not guarantee any treasures inside ‚Äì it's purely structural.
	IsSwampExist(ctx context.Context, in *IsSwampExistRequest, opts ...grpc.CallOption) (*IsSwampExistResponse, error)
	// IsKeyExist checks whether a specific key exists in a given swamp.
	//
	// This allows you to verify the presence of a treasure without retrieving its content.
	//
	// Use cases include:
	// - Validation before conditional logic (e.g. overwrite if exists)
	// - Data consistency checks
	// - TTL-aware logic (e.g. only update if key is still present)
	//
	// üí° Note: The value is not returned ‚Äì only a boolean indicator of existence.
	IsKeyExist(ctx context.Context, in *IsKeyExistRequest, opts ...grpc.CallOption) (*IsKeyExistResponse, error)
	// SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.
	//
	// When any treasure in the swamp is created, updated, or deleted,
	// the subscriber immediately receives an event via the gRPC stream.
	//
	// Each event includes:
	// - The new Treasure (after Set, Shift, etc.)
	// - The previous Treasure (if updated)
	// - The deleted Treasure (if removed)
	// - The EventType: NEW, UPDATED, DELETED, etc.
	// - The timestamp of the change
	//
	// üîÅ Events are streamed continuously and in real time, making this ideal for:
	// - Realtime dashboards
	// - Reactive frontends (e.g. auto-refreshing tables)
	// - Notification systems
	// - Chat or messaging systems (event-driven communication)
	// - Distributed coordination (e.g. data sync across services)
	// - Microservice communication via event stream
	//
	// üí° You can use this to completely replace traditional polling or cron-based checks.
	SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeToEventsResponse], error)
	// SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.
	//
	// Whenever the number of treasures changes in the swamp (insert, delete, expire),
	// the client receives a realtime update of the current element count.
	//
	// This is useful for:
	// - Showing live counters or progress bars
	// - Monitoring queue sizes
	// - Displaying health metrics or swamp saturation
	//
	// ‚ö° Events are sent immediately upon any change to the number of elements.
	SubscribeToInfo(ctx context.Context, in *SubscribeToInfoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeToInfoResponse], error)
	// Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.
	//
	// üí° HydrAIDE automatically ensures that each value is unique within the slice.
	// If a number already exists, it will be ignored ‚Äì no duplicates are ever stored.
	//
	// You can safely push multiple values at once, even if some already exist.
	// The resulting slice will contain only distinct uint32 values.
	//
	// üîî Any change to the slice triggers a real-time event to all swamp subscribers.
	// The full updated slice is included in the event payload.
	//
	// This feature is ideal for building:
	// - Reverse indexes (e.g. word ‚Üí [domainHash1, domainHash2])
	// - Subscriptions, permissions, ID-based tagging
	// - Memory-efficient, append-only ID lists
	//
	// ‚ö†Ô∏è Recommended for cases where the slice size is small to moderate,
	// as the full slice is returned on each update.
	Uint32SlicePush(ctx context.Context, in *AddToUint32SlicePushRequest, opts ...grpc.CallOption) (*AddToUint32SlicePushResponse, error)
	// Uint32SliceDelete removes one or more uint32 values from one or more slices.
	//
	// If a value does not exist, it is silently ignored (no error thrown).
	// The key itself (treasure) is preserved ‚Äì only the values inside the slice are modified.
	//
	// üîî The deletion also triggers a real-time event to all subscribers.
	Uint32SliceDelete(ctx context.Context, in *Uint32SliceDeleteRequest, opts ...grpc.CallOption) (*Uint32SliceDeleteResponse, error)
	// Uint32SliceSize returns the number of values stored in the uint32 slice.
	//
	// Use this to:
	// - Show visual counters
	// - Estimate memory usage
	// - Monitor collection density
	Uint32SliceSize(ctx context.Context, in *Uint32SliceSizeRequest, opts ...grpc.CallOption) (*Uint32SliceSizeResponse, error)
	// Uint32SliceIsValueExist checks whether a specific value exists inside the slice.
	//
	// This is useful when you want to validate membership before taking actions,
	// such as displaying UI states or preventing duplicate logic.
	Uint32SliceIsValueExist(ctx context.Context, in *Uint32SliceIsValueExistRequest, opts ...grpc.CallOption) (*Uint32SliceIsValueExistResponse, error)
	// IncrementInt8 increments (or decrements) the value of the key by the specified amount,
	// if a given condition is satisfied.
	//
	// üí° The increment can be negative ‚Äì enabling both increment and decrement operations.
	// If the condition fails, the value is not modified.
	//
	// The response includes:
	// - The new (or original) value
	// - Whether the increment was applied
	//
	// üîî Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.
	//
	// Typical use cases:
	// - Counter logic (votes, likes, attempts)
	// - Conditional stock adjustments
	// - Quota or retry limits
	IncrementInt8(ctx context.Context, in *IncrementInt8Request, opts ...grpc.CallOption) (*IncrementInt8Response, error)
	// IncrementInt8 same logic as IncrementInt8 but for int16 values
	IncrementInt16(ctx context.Context, in *IncrementInt16Request, opts ...grpc.CallOption) (*IncrementInt16Response, error)
	// IncrementInt32 same logic as IncrementInt8 but for int32 values
	IncrementInt32(ctx context.Context, in *IncrementInt32Request, opts ...grpc.CallOption) (*IncrementInt32Response, error)
	// IncrementInt64 same logic as IncrementInt8 but for int64 values
	IncrementInt64(ctx context.Context, in *IncrementInt64Request, opts ...grpc.CallOption) (*IncrementInt64Response, error)
	// IncrementUint8 same logic as IncrementInt8 but for uint8 values
	IncrementUint8(ctx context.Context, in *IncrementUint8Request, opts ...grpc.CallOption) (*IncrementUint8Response, error)
	// IncrementUint16 same logic as IncrementInt8 but for uint16 values
	IncrementUint16(ctx context.Context, in *IncrementUint16Request, opts ...grpc.CallOption) (*IncrementUint16Response, error)
	// IncrementUint32 same logic as IncrementInt8 but for uint32 values
	IncrementUint32(ctx context.Context, in *IncrementUint32Request, opts ...grpc.CallOption) (*IncrementUint32Response, error)
	// IncrementUint64 same logic as IncrementInt8 but for uint64 values
	IncrementUint64(ctx context.Context, in *IncrementUint64Request, opts ...grpc.CallOption) (*IncrementUint64Response, error)
	// IncrementFloat32 same logic as IncrementInt8 but for float32 values
	IncrementFloat32(ctx context.Context, in *IncrementFloat32Request, opts ...grpc.CallOption) (*IncrementFloat32Response, error)
	// IncrementFloat64 same logic as IncrementInt8 but for float64 values
	IncrementFloat64(ctx context.Context, in *IncrementFloat64Request, opts ...grpc.CallOption) (*IncrementFloat64Response, error)
}

type hydraideServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewHydraideServiceClient(cc grpc.ClientConnInterface) HydraideServiceClient {
	return &hydraideServiceClient{cc}
}

func (c *hydraideServiceClient) Heartbeat(ctx context.Context, in *HeartbeatRequest, opts ...grpc.CallOption) (*HeartbeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HeartbeatResponse)
	err := c.cc.Invoke(ctx, HydraideService_Heartbeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Lock(ctx context.Context, in *LockRequest, opts ...grpc.CallOption) (*LockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LockResponse)
	err := c.cc.Invoke(ctx, HydraideService_Lock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Unlock(ctx context.Context, in *UnlockRequest, opts ...grpc.CallOption) (*UnlockResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UnlockResponse)
	err := c.cc.Invoke(ctx, HydraideService_Unlock_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) RegisterSwamp(ctx context.Context, in *RegisterSwampRequest, opts ...grpc.CallOption) (*RegisterSwampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegisterSwampResponse)
	err := c.cc.Invoke(ctx, HydraideService_RegisterSwamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) DeRegisterSwamp(ctx context.Context, in *DeRegisterSwampRequest, opts ...grpc.CallOption) (*DeRegisterSwampResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeRegisterSwampResponse)
	err := c.cc.Invoke(ctx, HydraideService_DeRegisterSwamp_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Set(ctx context.Context, in *SetRequest, opts ...grpc.CallOption) (*SetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetResponse)
	err := c.cc.Invoke(ctx, HydraideService_Set_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Get(ctx context.Context, in *GetRequest, opts ...grpc.CallOption) (*GetResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetResponse)
	err := c.cc.Invoke(ctx, HydraideService_Get_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) GetAll(ctx context.Context, in *GetAllRequest, opts ...grpc.CallOption) (*GetAllResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetAllResponse)
	err := c.cc.Invoke(ctx, HydraideService_GetAll_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) GetByIndex(ctx context.Context, in *GetByIndexRequest, opts ...grpc.CallOption) (*GetByIndexResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetByIndexResponse)
	err := c.cc.Invoke(ctx, HydraideService_GetByIndex_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) GetByKeys(ctx context.Context, in *GetByKeysRequest, opts ...grpc.CallOption) (*GetByKeysResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetByKeysResponse)
	err := c.cc.Invoke(ctx, HydraideService_GetByKeys_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) ShiftExpiredTreasures(ctx context.Context, in *ShiftExpiredTreasuresRequest, opts ...grpc.CallOption) (*ShiftExpiredTreasuresResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ShiftExpiredTreasuresResponse)
	err := c.cc.Invoke(ctx, HydraideService_ShiftExpiredTreasures_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Destroy(ctx context.Context, in *DestroyRequest, opts ...grpc.CallOption) (*DestroyResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DestroyResponse)
	err := c.cc.Invoke(ctx, HydraideService_Destroy_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Delete(ctx context.Context, in *DeleteRequest, opts ...grpc.CallOption) (*DeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, HydraideService_Delete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CountResponse)
	err := c.cc.Invoke(ctx, HydraideService_Count_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IsSwampExist(ctx context.Context, in *IsSwampExistRequest, opts ...grpc.CallOption) (*IsSwampExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsSwampExistResponse)
	err := c.cc.Invoke(ctx, HydraideService_IsSwampExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IsKeyExist(ctx context.Context, in *IsKeyExistRequest, opts ...grpc.CallOption) (*IsKeyExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IsKeyExistResponse)
	err := c.cc.Invoke(ctx, HydraideService_IsKeyExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) SubscribeToEvents(ctx context.Context, in *SubscribeToEventsRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeToEventsResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HydraideService_ServiceDesc.Streams[0], HydraideService_SubscribeToEvents_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToEventsRequest, SubscribeToEventsResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HydraideService_SubscribeToEventsClient = grpc.ServerStreamingClient[SubscribeToEventsResponse]

func (c *hydraideServiceClient) SubscribeToInfo(ctx context.Context, in *SubscribeToInfoRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[SubscribeToInfoResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &HydraideService_ServiceDesc.Streams[1], HydraideService_SubscribeToInfo_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeToInfoRequest, SubscribeToInfoResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HydraideService_SubscribeToInfoClient = grpc.ServerStreamingClient[SubscribeToInfoResponse]

func (c *hydraideServiceClient) Uint32SlicePush(ctx context.Context, in *AddToUint32SlicePushRequest, opts ...grpc.CallOption) (*AddToUint32SlicePushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AddToUint32SlicePushResponse)
	err := c.cc.Invoke(ctx, HydraideService_Uint32SlicePush_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Uint32SliceDelete(ctx context.Context, in *Uint32SliceDeleteRequest, opts ...grpc.CallOption) (*Uint32SliceDeleteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceDeleteResponse)
	err := c.cc.Invoke(ctx, HydraideService_Uint32SliceDelete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Uint32SliceSize(ctx context.Context, in *Uint32SliceSizeRequest, opts ...grpc.CallOption) (*Uint32SliceSizeResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceSizeResponse)
	err := c.cc.Invoke(ctx, HydraideService_Uint32SliceSize_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) Uint32SliceIsValueExist(ctx context.Context, in *Uint32SliceIsValueExistRequest, opts ...grpc.CallOption) (*Uint32SliceIsValueExistResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Uint32SliceIsValueExistResponse)
	err := c.cc.Invoke(ctx, HydraideService_Uint32SliceIsValueExist_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementInt8(ctx context.Context, in *IncrementInt8Request, opts ...grpc.CallOption) (*IncrementInt8Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt8Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementInt8_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementInt16(ctx context.Context, in *IncrementInt16Request, opts ...grpc.CallOption) (*IncrementInt16Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt16Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementInt16_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementInt32(ctx context.Context, in *IncrementInt32Request, opts ...grpc.CallOption) (*IncrementInt32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt32Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementInt32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementInt64(ctx context.Context, in *IncrementInt64Request, opts ...grpc.CallOption) (*IncrementInt64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementInt64Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementInt64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementUint8(ctx context.Context, in *IncrementUint8Request, opts ...grpc.CallOption) (*IncrementUint8Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint8Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementUint8_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementUint16(ctx context.Context, in *IncrementUint16Request, opts ...grpc.CallOption) (*IncrementUint16Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint16Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementUint16_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementUint32(ctx context.Context, in *IncrementUint32Request, opts ...grpc.CallOption) (*IncrementUint32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint32Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementUint32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementUint64(ctx context.Context, in *IncrementUint64Request, opts ...grpc.CallOption) (*IncrementUint64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementUint64Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementUint64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementFloat32(ctx context.Context, in *IncrementFloat32Request, opts ...grpc.CallOption) (*IncrementFloat32Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementFloat32Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementFloat32_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hydraideServiceClient) IncrementFloat64(ctx context.Context, in *IncrementFloat64Request, opts ...grpc.CallOption) (*IncrementFloat64Response, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(IncrementFloat64Response)
	err := c.cc.Invoke(ctx, HydraideService_IncrementFloat64_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HydraideServiceServer is the server API for HydraideService service.
// All implementations must embed UnimplementedHydraideServiceServer
// for forward compatibility.
type HydraideServiceServer interface {
	// Heartbeat checks if the HydrAIDE server is alive.
	// The client sends a Ping and expects a Pong response.
	Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error)
	// Lock allows you to create a mutex-like lock based on a given key.
	// It queues all lock requests for the same key and only returns once the lock is granted.
	// This mechanism enables swamp- or treasure-level locking to coordinate access between microservices.
	//
	// ‚ö†Ô∏è Note: Locking is logical only ‚Äî it does not block the actual data access unless your logic respects the lock.
	// You must explicitly use the Lock/Unlock sequence around relevant operations.
	//
	// Required: TTL must be set (timeout in milliseconds).
	// If the lock cannot be acquired within this TTL, the call returns an error.
	// If a lock is granted, a LockID is returned, which must be passed to Unlock.
	Lock(context.Context, *LockRequest) (*LockResponse, error)
	// Unlock releases the previously granted lock based on the key and LockID.
	// If the LockID is invalid or does not match an existing lock, the call fails.
	//
	// It is crucial to always unlock your locks to avoid deadlocks.
	// If the TTL expires, the lock is automatically released.
	Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error)
	// RegisterSwamp registers a new swamp pattern in the HydrAIDE system.
	// A swamp pattern defines the namespace (Sanctuary/Realm/Swamp) and behavior of a storage unit.
	//
	// You can configure:
	// - Whether the swamp lives in memory or on disk
	// - How long it should stay alive without access (CloseAfterIdle)
	// - How frequently it should flush to disk (WriteInterval)
	// - Maximum file size per chunk (MaxFileSize)
	//
	// Use this to define behavior per collection before inserting data.
	RegisterSwamp(context.Context, *RegisterSwampRequest) (*RegisterSwampResponse, error)
	// DeRegisterSwamp removes a previously registered swamp pattern.
	// This does not delete the swamp data ‚Äî it only removes its active configuration.
	//
	// Use this to clean up unused swamp definitions.
	DeRegisterSwamp(context.Context, *DeRegisterSwampRequest) (*DeRegisterSwampResponse, error)
	// Set inserts or updates one or more key-value pairs into one or more swamps.
	// You can control the behavior using two flags:
	// - CreateIfNotExist: If false, the swamp/key must already exist (update only).
	// - Overwrite: If false, the existing value will not be overwritten.
	//
	// ‚ö†Ô∏è Each KeyValuePair supports multiple data types:
	// - All numeric primitives: int8, int16, int32, int64, uint8, uint16, uint32, uint64
	// - Floating point types: float32, float64
	// - Booleans, strings, bytes, and even slices (e.g., uint32[])
	//
	// üí° HydrAIDE stores the value using its **actual underlying type** without upcasting,
	// which means no wasted memory or disk space ‚Äì you only store what you really need.
	//
	// You can also set metadata like CreatedAt, UpdatedBy, ExpiredAt, etc.
	//
	// ‚úÖ Supports multiple swamps in a single request for batch operations.
	//
	// üîî Realtime: Any inserted or updated treasures will trigger an immediate
	// event to all active subscribers via the SubscribeToEvents stream.
	//
	// This makes HydrAIDE suitable for:
	// - Real-time dashboards
	// - Cache invalidation listeners
	// - Live analytics feeds
	Set(context.Context, *SetRequest) (*SetResponse, error)
	// Get retrieves one or more key-value pairs by key from one or more swamps.
	// You must specify the swamp name and the list of keys per swamp.
	//
	// Each response includes the key, value, and metadata fields (timestamps, creators).
	// This is a type-safe, structured read ‚Äì no JSON parsing needed on the client side.
	Get(context.Context, *GetRequest) (*GetResponse, error)
	// GetAll retrieves **all** key-value pairs from a given swamp.
	//
	// This is useful for debug purposes, cache rebuilding, or initial snapshot creation.
	// Not recommended for large datasets unless scoped and filtered client-side.
	GetAll(context.Context, *GetAllRequest) (*GetAllResponse, error)
	// GetByIndex allows indexed reads based on fields like:
	// - ExpirationTime
	// - CreationTime
	// - Value types (e.g., VALUE_STRING, VALUE_INT32, etc.)
	//
	// You can specify the index type, sorting order (ASC/DESC), and a range using From/Limit.
	// This makes the HydrAIDE engine powerful for search, feed, and queue-like structures.
	//
	// ‚ö†Ô∏è HydrAIDE creates index structures on-demand in memory when this method is called.
	// These indexes are **not persisted**, and are **discarded when the swamp is closed** due to inactivity.
	// This means indexing is stateless, fast, and leaves no storage overhead.
	//
	// You do not need to pre-define indexes. Simply call this method with the right IndexType.
	GetByIndex(context.Context, *GetByIndexRequest) (*GetByIndexResponse, error)
	// GetByKeys allows efficient multi-key read operations from a single Swamp in one request.
	//
	// This feature is called **CatalogReadBatch**, and it allows clients to pass a list of keys
	// and receive all existing Treasures in a single response, rather than calling `Get()` multiple times.
	//
	// The goal is to reduce roundtrip latency and network overhead when fetching many records by known keys
	// (for example, when using secondary indexes).
	//
	// ‚ö†Ô∏è Behavioral notes:
	// - The request can contain any number of keys (bounded by server configuration).
	// - The response may be unordered ‚Äî the server does not need to preserve key order.
	// - Missing keys are silently ignored (they simply don't appear in the response).
	// - If none of the keys exist, the response should be empty (not an error).
	// - Errors (connection, invalid argument, etc.) follow the same error semantics as `GetByIndex`.
	//
	// üí° Why this is needed:
	// When using secondary indexes, HydrAIDE users often have to read dozens or hundreds of Treasures by known keys.
	// Currently, this requires multiple `CatalogRead()` calls (one per key), causing N+1 network roundtrips.
	// With `GetByKeys`, the same can be done with a *single RPC call*, improving throughput by 30‚Äì50√ó
	// and reducing latency dramatically.
	GetByKeys(context.Context, *GetByKeysRequest) (*GetByKeysResponse, error)
	// ShiftExpiredTreasures retrieves and deletes expired treasures from a given swamp.
	//
	// This method is ideal for implementing task queues, time-based processing systems,
	// or scheduled cleanup mechanisms where only expired items should be processed.
	//
	// You can control how many items to retrieve at once using the `HowMany` parameter:
	// - If `HowMany` is 0, all expired treasures will be returned (use with caution on large swamps)
	// - If `HowMany` > 0, only that many expired entries will be returned in the response
	//
	// ‚ö†Ô∏è Important: This method is destructive ‚Äì the returned items will be permanently removed from the swamp.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this for building things like:
	// - Delayed jobs
	// - Expiring caches
	// - Scheduled triggers (e.g. publish-after-expiry)
	ShiftExpiredTreasures(context.Context, *ShiftExpiredTreasuresRequest) (*ShiftExpiredTreasuresResponse, error)
	// Destroy permanently deletes the entire swamp and all its treasures.
	//
	// This removes all data associated with the given swamp, including metadata, indexes, and chunks.
	//
	// ‚ö†Ô∏è Warning: This operation is irreversible. All data will be lost.
	// Use only when you're absolutely sure the swamp is no longer needed.
	//
	// Typical use cases:
	// - Cleanup after tests or temporary data
	// - User data deletion requests
	// - Full environment reset
	Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error)
	// Delete removes one or more treasures (key-value pairs) from the specified swamp.
	//
	// This is a precise, non-destructive swamp-level operation.
	// You must provide the swamp name and the list of keys to delete.
	//
	// ‚úÖ Supports batch deletion across multiple swamps in a single request.
	// Each swamp and its deleted keys will be included in the response.
	//
	// üîî Realtime: All subscribers to the swamp will receive an immediate
	// notification about the deleted treasures via the SubscribeToEvents stream.
	//
	// Use this to:
	// - Manually remove outdated or invalid entries
	// - Implement "soft delete" logic (client-side)
	// - Perform targeted cleanup operations
	Delete(context.Context, *DeleteRequest) (*DeleteResponse, error)
	// Count returns the number of treasures in one or more specified swamps.
	//
	// You provide a list of swamp names, and for each swamp HydrAIDE returns:
	// - Whether the swamp exists
	// - How many elements (treasures) are currently stored in it
	//
	// ‚úÖ This is useful for:
	// - Dashboard metrics and monitoring
	// - Queue size estimation
	// - Expiry-aware cleanup or batch logic
	//
	// üí° The count is calculated instantly from the swamp‚Äôs current state,
	// with no need for full traversal or manual iteration.
	//
	// Can be used across multiple swamps in a single request.
	Count(context.Context, *CountRequest) (*CountResponse, error)
	// IsSwampExist checks if the specified swamp exists in the given sanctuary.
	//
	// This method does not create or modify anything ‚Äì it only verifies existence.
	// Use it to validate swamp names before writing, migrating, or deleting.
	//
	// Typical use cases:
	// - Pre-checks before Set/Delete operations
	// - UI/UX logic (e.g. show/hide a swamp)
	// - Schema validation before batch processing
	//
	// üí° Note: Swamp existence does not guarantee any treasures inside ‚Äì it's purely structural.
	IsSwampExist(context.Context, *IsSwampExistRequest) (*IsSwampExistResponse, error)
	// IsKeyExist checks whether a specific key exists in a given swamp.
	//
	// This allows you to verify the presence of a treasure without retrieving its content.
	//
	// Use cases include:
	// - Validation before conditional logic (e.g. overwrite if exists)
	// - Data consistency checks
	// - TTL-aware logic (e.g. only update if key is still present)
	//
	// üí° Note: The value is not returned ‚Äì only a boolean indicator of existence.
	IsKeyExist(context.Context, *IsKeyExistRequest) (*IsKeyExistResponse, error)
	// SubscribeToEvents allows clients to subscribe to **all data changes** within a given swamp.
	//
	// When any treasure in the swamp is created, updated, or deleted,
	// the subscriber immediately receives an event via the gRPC stream.
	//
	// Each event includes:
	// - The new Treasure (after Set, Shift, etc.)
	// - The previous Treasure (if updated)
	// - The deleted Treasure (if removed)
	// - The EventType: NEW, UPDATED, DELETED, etc.
	// - The timestamp of the change
	//
	// üîÅ Events are streamed continuously and in real time, making this ideal for:
	// - Realtime dashboards
	// - Reactive frontends (e.g. auto-refreshing tables)
	// - Notification systems
	// - Chat or messaging systems (event-driven communication)
	// - Distributed coordination (e.g. data sync across services)
	// - Microservice communication via event stream
	//
	// üí° You can use this to completely replace traditional polling or cron-based checks.
	SubscribeToEvents(*SubscribeToEventsRequest, grpc.ServerStreamingServer[SubscribeToEventsResponse]) error
	// SubscribeToInfo allows clients to subscribe to the **size** of a given swamp.
	//
	// Whenever the number of treasures changes in the swamp (insert, delete, expire),
	// the client receives a realtime update of the current element count.
	//
	// This is useful for:
	// - Showing live counters or progress bars
	// - Monitoring queue sizes
	// - Displaying health metrics or swamp saturation
	//
	// ‚ö° Events are sent immediately upon any change to the number of elements.
	SubscribeToInfo(*SubscribeToInfoRequest, grpc.ServerStreamingServer[SubscribeToInfoResponse]) error
	// Uint32SlicePush adds one or more uint32 values to one or more uint32 slices stored in a swamp.
	//
	// üí° HydrAIDE automatically ensures that each value is unique within the slice.
	// If a number already exists, it will be ignored ‚Äì no duplicates are ever stored.
	//
	// You can safely push multiple values at once, even if some already exist.
	// The resulting slice will contain only distinct uint32 values.
	//
	// üîî Any change to the slice triggers a real-time event to all swamp subscribers.
	// The full updated slice is included in the event payload.
	//
	// This feature is ideal for building:
	// - Reverse indexes (e.g. word ‚Üí [domainHash1, domainHash2])
	// - Subscriptions, permissions, ID-based tagging
	// - Memory-efficient, append-only ID lists
	//
	// ‚ö†Ô∏è Recommended for cases where the slice size is small to moderate,
	// as the full slice is returned on each update.
	Uint32SlicePush(context.Context, *AddToUint32SlicePushRequest) (*AddToUint32SlicePushResponse, error)
	// Uint32SliceDelete removes one or more uint32 values from one or more slices.
	//
	// If a value does not exist, it is silently ignored (no error thrown).
	// The key itself (treasure) is preserved ‚Äì only the values inside the slice are modified.
	//
	// üîî The deletion also triggers a real-time event to all subscribers.
	Uint32SliceDelete(context.Context, *Uint32SliceDeleteRequest) (*Uint32SliceDeleteResponse, error)
	// Uint32SliceSize returns the number of values stored in the uint32 slice.
	//
	// Use this to:
	// - Show visual counters
	// - Estimate memory usage
	// - Monitor collection density
	Uint32SliceSize(context.Context, *Uint32SliceSizeRequest) (*Uint32SliceSizeResponse, error)
	// Uint32SliceIsValueExist checks whether a specific value exists inside the slice.
	//
	// This is useful when you want to validate membership before taking actions,
	// such as displaying UI states or preventing duplicate logic.
	Uint32SliceIsValueExist(context.Context, *Uint32SliceIsValueExistRequest) (*Uint32SliceIsValueExistResponse, error)
	// IncrementInt8 increments (or decrements) the value of the key by the specified amount,
	// if a given condition is satisfied.
	//
	// üí° The increment can be negative ‚Äì enabling both increment and decrement operations.
	// If the condition fails, the value is not modified.
	//
	// The response includes:
	// - The new (or original) value
	// - Whether the increment was applied
	//
	// üîî Realtime: Any change triggers an immediate event to all swamp subscribers via SubscribeToEvents.
	//
	// Typical use cases:
	// - Counter logic (votes, likes, attempts)
	// - Conditional stock adjustments
	// - Quota or retry limits
	IncrementInt8(context.Context, *IncrementInt8Request) (*IncrementInt8Response, error)
	// IncrementInt8 same logic as IncrementInt8 but for int16 values
	IncrementInt16(context.Context, *IncrementInt16Request) (*IncrementInt16Response, error)
	// IncrementInt32 same logic as IncrementInt8 but for int32 values
	IncrementInt32(context.Context, *IncrementInt32Request) (*IncrementInt32Response, error)
	// IncrementInt64 same logic as IncrementInt8 but for int64 values
	IncrementInt64(context.Context, *IncrementInt64Request) (*IncrementInt64Response, error)
	// IncrementUint8 same logic as IncrementInt8 but for uint8 values
	IncrementUint8(context.Context, *IncrementUint8Request) (*IncrementUint8Response, error)
	// IncrementUint16 same logic as IncrementInt8 but for uint16 values
	IncrementUint16(context.Context, *IncrementUint16Request) (*IncrementUint16Response, error)
	// IncrementUint32 same logic as IncrementInt8 but for uint32 values
	IncrementUint32(context.Context, *IncrementUint32Request) (*IncrementUint32Response, error)
	// IncrementUint64 same logic as IncrementInt8 but for uint64 values
	IncrementUint64(context.Context, *IncrementUint64Request) (*IncrementUint64Response, error)
	// IncrementFloat32 same logic as IncrementInt8 but for float32 values
	IncrementFloat32(context.Context, *IncrementFloat32Request) (*IncrementFloat32Response, error)
	// IncrementFloat64 same logic as IncrementInt8 but for float64 values
	IncrementFloat64(context.Context, *IncrementFloat64Request) (*IncrementFloat64Response, error)
	mustEmbedUnimplementedHydraideServiceServer()
}

// UnimplementedHydraideServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedHydraideServiceServer struct{}

func (UnimplementedHydraideServiceServer) Heartbeat(context.Context, *HeartbeatRequest) (*HeartbeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Heartbeat not implemented")
}
func (UnimplementedHydraideServiceServer) Lock(context.Context, *LockRequest) (*LockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Lock not implemented")
}
func (UnimplementedHydraideServiceServer) Unlock(context.Context, *UnlockRequest) (*UnlockResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Unlock not implemented")
}
func (UnimplementedHydraideServiceServer) RegisterSwamp(context.Context, *RegisterSwampRequest) (*RegisterSwampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterSwamp not implemented")
}
func (UnimplementedHydraideServiceServer) DeRegisterSwamp(context.Context, *DeRegisterSwampRequest) (*DeRegisterSwampResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeRegisterSwamp not implemented")
}
func (UnimplementedHydraideServiceServer) Set(context.Context, *SetRequest) (*SetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Set not implemented")
}
func (UnimplementedHydraideServiceServer) Get(context.Context, *GetRequest) (*GetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedHydraideServiceServer) GetAll(context.Context, *GetAllRequest) (*GetAllResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAll not implemented")
}
func (UnimplementedHydraideServiceServer) GetByIndex(context.Context, *GetByIndexRequest) (*GetByIndexResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByIndex not implemented")
}
func (UnimplementedHydraideServiceServer) GetByKeys(context.Context, *GetByKeysRequest) (*GetByKeysResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetByKeys not implemented")
}
func (UnimplementedHydraideServiceServer) ShiftExpiredTreasures(context.Context, *ShiftExpiredTreasuresRequest) (*ShiftExpiredTreasuresResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShiftExpiredTreasures not implemented")
}
func (UnimplementedHydraideServiceServer) Destroy(context.Context, *DestroyRequest) (*DestroyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Destroy not implemented")
}
func (UnimplementedHydraideServiceServer) Delete(context.Context, *DeleteRequest) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedHydraideServiceServer) Count(context.Context, *CountRequest) (*CountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Count not implemented")
}
func (UnimplementedHydraideServiceServer) IsSwampExist(context.Context, *IsSwampExistRequest) (*IsSwampExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSwampExist not implemented")
}
func (UnimplementedHydraideServiceServer) IsKeyExist(context.Context, *IsKeyExistRequest) (*IsKeyExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsKeyExist not implemented")
}
func (UnimplementedHydraideServiceServer) SubscribeToEvents(*SubscribeToEventsRequest, grpc.ServerStreamingServer[SubscribeToEventsResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToEvents not implemented")
}
func (UnimplementedHydraideServiceServer) SubscribeToInfo(*SubscribeToInfoRequest, grpc.ServerStreamingServer[SubscribeToInfoResponse]) error {
	return status.Errorf(codes.Unimplemented, "method SubscribeToInfo not implemented")
}
func (UnimplementedHydraideServiceServer) Uint32SlicePush(context.Context, *AddToUint32SlicePushRequest) (*AddToUint32SlicePushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SlicePush not implemented")
}
func (UnimplementedHydraideServiceServer) Uint32SliceDelete(context.Context, *Uint32SliceDeleteRequest) (*Uint32SliceDeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceDelete not implemented")
}
func (UnimplementedHydraideServiceServer) Uint32SliceSize(context.Context, *Uint32SliceSizeRequest) (*Uint32SliceSizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceSize not implemented")
}
func (UnimplementedHydraideServiceServer) Uint32SliceIsValueExist(context.Context, *Uint32SliceIsValueExistRequest) (*Uint32SliceIsValueExistResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Uint32SliceIsValueExist not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementInt8(context.Context, *IncrementInt8Request) (*IncrementInt8Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt8 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementInt16(context.Context, *IncrementInt16Request) (*IncrementInt16Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt16 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementInt32(context.Context, *IncrementInt32Request) (*IncrementInt32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt32 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementInt64(context.Context, *IncrementInt64Request) (*IncrementInt64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementInt64 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementUint8(context.Context, *IncrementUint8Request) (*IncrementUint8Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint8 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementUint16(context.Context, *IncrementUint16Request) (*IncrementUint16Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint16 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementUint32(context.Context, *IncrementUint32Request) (*IncrementUint32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint32 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementUint64(context.Context, *IncrementUint64Request) (*IncrementUint64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementUint64 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementFloat32(context.Context, *IncrementFloat32Request) (*IncrementFloat32Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementFloat32 not implemented")
}
func (UnimplementedHydraideServiceServer) IncrementFloat64(context.Context, *IncrementFloat64Request) (*IncrementFloat64Response, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IncrementFloat64 not implemented")
}
func (UnimplementedHydraideServiceServer) mustEmbedUnimplementedHydraideServiceServer() {}
func (UnimplementedHydraideServiceServer) testEmbeddedByValue()                         {}

// UnsafeHydraideServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HydraideServiceServer will
// result in compilation errors.
type UnsafeHydraideServiceServer interface {
	mustEmbedUnimplementedHydraideServiceServer()
}

func RegisterHydraideServiceServer(s grpc.ServiceRegistrar, srv HydraideServiceServer) {
	// If the following call pancis, it indicates UnimplementedHydraideServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&HydraideService_ServiceDesc, srv)
}

func _HydraideService_Heartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HeartbeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Heartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Heartbeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Heartbeat(ctx, req.(*HeartbeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Lock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Lock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Lock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Lock(ctx, req.(*LockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Unlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Unlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Unlock_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Unlock(ctx, req.(*UnlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_RegisterSwamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterSwampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).RegisterSwamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_RegisterSwamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).RegisterSwamp(ctx, req.(*RegisterSwampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_DeRegisterSwamp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeRegisterSwampRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).DeRegisterSwamp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_DeRegisterSwamp_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).DeRegisterSwamp(ctx, req.(*DeRegisterSwampRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Set_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Set(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Set_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Set(ctx, req.(*SetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Get(ctx, req.(*GetRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_GetAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAllRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).GetAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_GetAll_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).GetAll(ctx, req.(*GetAllRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_GetByIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByIndexRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).GetByIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_GetByIndex_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).GetByIndex(ctx, req.(*GetByIndexRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_GetByKeys_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetByKeysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).GetByKeys(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_GetByKeys_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).GetByKeys(ctx, req.(*GetByKeysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_ShiftExpiredTreasures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShiftExpiredTreasuresRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).ShiftExpiredTreasures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_ShiftExpiredTreasures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).ShiftExpiredTreasures(ctx, req.(*ShiftExpiredTreasuresRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Destroy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DestroyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Destroy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Destroy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Destroy(ctx, req.(*DestroyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Delete(ctx, req.(*DeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Count_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IsSwampExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsSwampExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IsSwampExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IsSwampExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IsSwampExist(ctx, req.(*IsSwampExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IsKeyExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsKeyExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IsKeyExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IsKeyExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IsKeyExist(ctx, req.(*IsKeyExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_SubscribeToEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToEventsRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HydraideServiceServer).SubscribeToEvents(m, &grpc.GenericServerStream[SubscribeToEventsRequest, SubscribeToEventsResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HydraideService_SubscribeToEventsServer = grpc.ServerStreamingServer[SubscribeToEventsResponse]

func _HydraideService_SubscribeToInfo_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeToInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(HydraideServiceServer).SubscribeToInfo(m, &grpc.GenericServerStream[SubscribeToInfoRequest, SubscribeToInfoResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type HydraideService_SubscribeToInfoServer = grpc.ServerStreamingServer[SubscribeToInfoResponse]

func _HydraideService_Uint32SlicePush_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddToUint32SlicePushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Uint32SlicePush(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Uint32SlicePush_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Uint32SlicePush(ctx, req.(*AddToUint32SlicePushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Uint32SliceDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceDeleteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Uint32SliceDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Uint32SliceDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Uint32SliceDelete(ctx, req.(*Uint32SliceDeleteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Uint32SliceSize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceSizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Uint32SliceSize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Uint32SliceSize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Uint32SliceSize(ctx, req.(*Uint32SliceSizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_Uint32SliceIsValueExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Uint32SliceIsValueExistRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).Uint32SliceIsValueExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_Uint32SliceIsValueExist_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).Uint32SliceIsValueExist(ctx, req.(*Uint32SliceIsValueExistRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementInt8_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt8Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementInt8(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementInt8_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementInt8(ctx, req.(*IncrementInt8Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementInt16_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt16Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementInt16(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementInt16_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementInt16(ctx, req.(*IncrementInt16Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementInt32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementInt32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementInt32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementInt32(ctx, req.(*IncrementInt32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementInt64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementInt64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementInt64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementInt64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementInt64(ctx, req.(*IncrementInt64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementUint8_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint8Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementUint8(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementUint8_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementUint8(ctx, req.(*IncrementUint8Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementUint16_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint16Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementUint16(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementUint16_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementUint16(ctx, req.(*IncrementUint16Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementUint32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementUint32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementUint32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementUint32(ctx, req.(*IncrementUint32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementUint64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementUint64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementUint64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementUint64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementUint64(ctx, req.(*IncrementUint64Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementFloat32_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementFloat32Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementFloat32(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementFloat32_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementFloat32(ctx, req.(*IncrementFloat32Request))
	}
	return interceptor(ctx, in, info, handler)
}

func _HydraideService_IncrementFloat64_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IncrementFloat64Request)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HydraideServiceServer).IncrementFloat64(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HydraideService_IncrementFloat64_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HydraideServiceServer).IncrementFloat64(ctx, req.(*IncrementFloat64Request))
	}
	return interceptor(ctx, in, info, handler)
}

// HydraideService_ServiceDesc is the grpc.ServiceDesc for HydraideService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HydraideService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hydraidepbgo.HydraideService",
	HandlerType: (*HydraideServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Heartbeat",
			Handler:    _HydraideService_Heartbeat_Handler,
		},
		{
			MethodName: "Lock",
			Handler:    _HydraideService_Lock_Handler,
		},
		{
			MethodName: "Unlock",
			Handler:    _HydraideService_Unlock_Handler,
		},
		{
			MethodName: "RegisterSwamp",
			Handler:    _HydraideService_RegisterSwamp_Handler,
		},
		{
			MethodName: "DeRegisterSwamp",
			Handler:    _HydraideService_DeRegisterSwamp_Handler,
		},
		{
			MethodName: "Set",
			Handler:    _HydraideService_Set_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _HydraideService_Get_Handler,
		},
		{
			MethodName: "GetAll",
			Handler:    _HydraideService_GetAll_Handler,
		},
		{
			MethodName: "GetByIndex",
			Handler:    _HydraideService_GetByIndex_Handler,
		},
		{
			MethodName: "GetByKeys",
			Handler:    _HydraideService_GetByKeys_Handler,
		},
		{
			MethodName: "ShiftExpiredTreasures",
			Handler:    _HydraideService_ShiftExpiredTreasures_Handler,
		},
		{
			MethodName: "Destroy",
			Handler:    _HydraideService_Destroy_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _HydraideService_Delete_Handler,
		},
		{
			MethodName: "Count",
			Handler:    _HydraideService_Count_Handler,
		},
		{
			MethodName: "IsSwampExist",
			Handler:    _HydraideService_IsSwampExist_Handler,
		},
		{
			MethodName: "IsKeyExist",
			Handler:    _HydraideService_IsKeyExist_Handler,
		},
		{
			MethodName: "Uint32SlicePush",
			Handler:    _HydraideService_Uint32SlicePush_Handler,
		},
		{
			MethodName: "Uint32SliceDelete",
			Handler:    _HydraideService_Uint32SliceDelete_Handler,
		},
		{
			MethodName: "Uint32SliceSize",
			Handler:    _HydraideService_Uint32SliceSize_Handler,
		},
		{
			MethodName: "Uint32SliceIsValueExist",
			Handler:    _HydraideService_Uint32SliceIsValueExist_Handler,
		},
		{
			MethodName: "IncrementInt8",
			Handler:    _HydraideService_IncrementInt8_Handler,
		},
		{
			MethodName: "IncrementInt16",
			Handler:    _HydraideService_IncrementInt16_Handler,
		},
		{
			MethodName: "IncrementInt32",
			Handler:    _HydraideService_IncrementInt32_Handler,
		},
		{
			MethodName: "IncrementInt64",
			Handler:    _HydraideService_IncrementInt64_Handler,
		},
		{
			MethodName: "IncrementUint8",
			Handler:    _HydraideService_IncrementUint8_Handler,
		},
		{
			MethodName: "IncrementUint16",
			Handler:    _HydraideService_IncrementUint16_Handler,
		},
		{
			MethodName: "IncrementUint32",
			Handler:    _HydraideService_IncrementUint32_Handler,
		},
		{
			MethodName: "IncrementUint64",
			Handler:    _HydraideService_IncrementUint64_Handler,
		},
		{
			MethodName: "IncrementFloat32",
			Handler:    _HydraideService_IncrementFloat32_Handler,
		},
		{
			MethodName: "IncrementFloat64",
			Handler:    _HydraideService_IncrementFloat64_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeToEvents",
			Handler:       _HydraideService_SubscribeToEvents_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SubscribeToInfo",
			Handler:       _HydraideService_SubscribeToInfo_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/hydraide.proto",
}
