// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.21.12
// source: hydraide.proto

package hydraidepbgo

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type SwampResponse_ErrCodeEnum int32

const (
	SwampResponse_CanNotBeExecuted  SwampResponse_ErrCodeEnum = 0
	SwampResponse_SwampDoesNotExist SwampResponse_ErrCodeEnum = 1
)

// Enum value maps for SwampResponse_ErrCodeEnum.
var (
	SwampResponse_ErrCodeEnum_name = map[int32]string{
		0: "CanNotBeExecuted",
		1: "SwampDoesNotExist",
	}
	SwampResponse_ErrCodeEnum_value = map[string]int32{
		"CanNotBeExecuted":  0,
		"SwampDoesNotExist": 1,
	}
)

func (x SwampResponse_ErrCodeEnum) Enum() *SwampResponse_ErrCodeEnum {
	p := new(SwampResponse_ErrCodeEnum)
	*p = x
	return p
}

func (x SwampResponse_ErrCodeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SwampResponse_ErrCodeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[0].Descriptor()
}

func (SwampResponse_ErrCodeEnum) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[0]
}

func (x SwampResponse_ErrCodeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SwampResponse_ErrCodeEnum.Descriptor instead.
func (SwampResponse_ErrCodeEnum) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{21, 0}
}

type Status_Code int32

const (
	Status_NOT_FOUND       Status_Code = 0 // The key does not exist and no changes were made
	Status_NEW             Status_Code = 1 // The key was newly created
	Status_UPDATED         Status_Code = 2 // The key existed and was updated
	Status_DELETED         Status_Code = 3 // The key was deleted
	Status_NOTHING_CHANGED Status_Code = 4 // Operation was skipped due to Overwrite=false or same value
)

// Enum value maps for Status_Code.
var (
	Status_Code_name = map[int32]string{
		0: "NOT_FOUND",
		1: "NEW",
		2: "UPDATED",
		3: "DELETED",
		4: "NOTHING_CHANGED",
	}
	Status_Code_value = map[string]int32{
		"NOT_FOUND":       0,
		"NEW":             1,
		"UPDATED":         2,
		"DELETED":         3,
		"NOTHING_CHANGED": 4,
	}
)

func (x Status_Code) Enum() *Status_Code {
	p := new(Status_Code)
	*p = x
	return p
}

func (x Status_Code) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Status_Code) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[1].Descriptor()
}

func (Status_Code) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[1]
}

func (x Status_Code) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Status_Code.Descriptor instead.
func (Status_Code) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{23, 0}
}

type Boolean_Type int32

const (
	Boolean_TRUE  Boolean_Type = 0
	Boolean_FALSE Boolean_Type = 1
)

// Enum value maps for Boolean_Type.
var (
	Boolean_Type_name = map[int32]string{
		0: "TRUE",
		1: "FALSE",
	}
	Boolean_Type_value = map[string]int32{
		"TRUE":  0,
		"FALSE": 1,
	}
)

func (x Boolean_Type) Enum() *Boolean_Type {
	p := new(Boolean_Type)
	*p = x
	return p
}

func (x Boolean_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Boolean_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[2].Descriptor()
}

func (Boolean_Type) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[2]
}

func (x Boolean_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Boolean_Type.Descriptor instead.
func (Boolean_Type) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{33, 0}
}

type IndexType_Type int32

const (
	// Key index (alphabetical)
	IndexType_KEY IndexType_Type = 0
	// Metadata-based indexes
	IndexType_EXPIRATION_TIME IndexType_Type = 1
	IndexType_CREATION_TIME   IndexType_Type = 2
	IndexType_UPDATE_TIME     IndexType_Type = 3
	// Value-based indexes
	IndexType_VALUE_INT8    IndexType_Type = 4
	IndexType_VALUE_INT16   IndexType_Type = 5
	IndexType_VALUE_INT32   IndexType_Type = 6
	IndexType_VALUE_INT64   IndexType_Type = 7
	IndexType_VALUE_UINT8   IndexType_Type = 8
	IndexType_VALUE_UINT16  IndexType_Type = 9
	IndexType_VALUE_UINT32  IndexType_Type = 10
	IndexType_VALUE_UINT64  IndexType_Type = 11
	IndexType_VALUE_FLOAT32 IndexType_Type = 12
	IndexType_VALUE_FLOAT64 IndexType_Type = 13
	IndexType_VALUE_STRING  IndexType_Type = 14
)

// Enum value maps for IndexType_Type.
var (
	IndexType_Type_name = map[int32]string{
		0:  "KEY",
		1:  "EXPIRATION_TIME",
		2:  "CREATION_TIME",
		3:  "UPDATE_TIME",
		4:  "VALUE_INT8",
		5:  "VALUE_INT16",
		6:  "VALUE_INT32",
		7:  "VALUE_INT64",
		8:  "VALUE_UINT8",
		9:  "VALUE_UINT16",
		10: "VALUE_UINT32",
		11: "VALUE_UINT64",
		12: "VALUE_FLOAT32",
		13: "VALUE_FLOAT64",
		14: "VALUE_STRING",
	}
	IndexType_Type_value = map[string]int32{
		"KEY":             0,
		"EXPIRATION_TIME": 1,
		"CREATION_TIME":   2,
		"UPDATE_TIME":     3,
		"VALUE_INT8":      4,
		"VALUE_INT16":     5,
		"VALUE_INT32":     6,
		"VALUE_INT64":     7,
		"VALUE_UINT8":     8,
		"VALUE_UINT16":    9,
		"VALUE_UINT32":    10,
		"VALUE_UINT64":    11,
		"VALUE_FLOAT32":   12,
		"VALUE_FLOAT64":   13,
		"VALUE_STRING":    14,
	}
)

func (x IndexType_Type) Enum() *IndexType_Type {
	p := new(IndexType_Type)
	*p = x
	return p
}

func (x IndexType_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IndexType_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[3].Descriptor()
}

func (IndexType_Type) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[3]
}

func (x IndexType_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IndexType_Type.Descriptor instead.
func (IndexType_Type) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{35, 0}
}

type OrderType_Type int32

const (
	OrderType_ASC  OrderType_Type = 0 // ascending
	OrderType_DESC OrderType_Type = 1 // descending
)

// Enum value maps for OrderType_Type.
var (
	OrderType_Type_name = map[int32]string{
		0: "ASC",
		1: "DESC",
	}
	OrderType_Type_value = map[string]int32{
		"ASC":  0,
		"DESC": 1,
	}
)

func (x OrderType_Type) Enum() *OrderType_Type {
	p := new(OrderType_Type)
	*p = x
	return p
}

func (x OrderType_Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (OrderType_Type) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[4].Descriptor()
}

func (OrderType_Type) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[4]
}

func (x OrderType_Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use OrderType_Type.Descriptor instead.
func (OrderType_Type) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{36, 0}
}

type DeleteResponse_SwampDeleteResponse_ErrorCodeEnum int32

const (
	DeleteResponse_SwampDeleteResponse_SwampDoesNotExist DeleteResponse_SwampDeleteResponse_ErrorCodeEnum = 0
)

// Enum value maps for DeleteResponse_SwampDeleteResponse_ErrorCodeEnum.
var (
	DeleteResponse_SwampDeleteResponse_ErrorCodeEnum_name = map[int32]string{
		0: "SwampDoesNotExist",
	}
	DeleteResponse_SwampDeleteResponse_ErrorCodeEnum_value = map[string]int32{
		"SwampDoesNotExist": 0,
	}
)

func (x DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) Enum() *DeleteResponse_SwampDeleteResponse_ErrorCodeEnum {
	p := new(DeleteResponse_SwampDeleteResponse_ErrorCodeEnum)
	*p = x
	return p
}

func (x DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[5].Descriptor()
}

func (DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[5]
}

func (x DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DeleteResponse_SwampDeleteResponse_ErrorCodeEnum.Descriptor instead.
func (DeleteResponse_SwampDeleteResponse_ErrorCodeEnum) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{39, 0, 0}
}

type Relational_Operator int32

const (
	Relational_EQUAL                 Relational_Operator = 0 // value == reference
	Relational_GREATER_THAN          Relational_Operator = 1 // value > reference
	Relational_GREATER_THAN_OR_EQUAL Relational_Operator = 2 // value >= reference
	Relational_LESS_THAN             Relational_Operator = 3 // value < reference
	Relational_LESS_THAN_OR_EQUAL    Relational_Operator = 4 // value <= reference
	Relational_NOT_EQUAL             Relational_Operator = 5 // value != reference
)

// Enum value maps for Relational_Operator.
var (
	Relational_Operator_name = map[int32]string{
		0: "EQUAL",
		1: "GREATER_THAN",
		2: "GREATER_THAN_OR_EQUAL",
		3: "LESS_THAN",
		4: "LESS_THAN_OR_EQUAL",
		5: "NOT_EQUAL",
	}
	Relational_Operator_value = map[string]int32{
		"EQUAL":                 0,
		"GREATER_THAN":          1,
		"GREATER_THAN_OR_EQUAL": 2,
		"LESS_THAN":             3,
		"LESS_THAN_OR_EQUAL":    4,
		"NOT_EQUAL":             5,
	}
)

func (x Relational_Operator) Enum() *Relational_Operator {
	p := new(Relational_Operator)
	*p = x
	return p
}

func (x Relational_Operator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Relational_Operator) Descriptor() protoreflect.EnumDescriptor {
	return file_hydraide_proto_enumTypes[6].Descriptor()
}

func (Relational_Operator) Type() protoreflect.EnumType {
	return &file_hydraide_proto_enumTypes[6]
}

func (x Relational_Operator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Relational_Operator.Descriptor instead.
func (Relational_Operator) EnumDescriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{69, 0}
}

type HeartbeatRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Ping is an arbitrary string sent by the client.
	// Usually used to test round-trip latency or connection health.
	Ping          string `protobuf:"bytes,1,opt,name=Ping,proto3" json:"Ping,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatRequest) Reset() {
	*x = HeartbeatRequest{}
	mi := &file_hydraide_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatRequest) ProtoMessage() {}

func (x *HeartbeatRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatRequest.ProtoReflect.Descriptor instead.
func (*HeartbeatRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{0}
}

func (x *HeartbeatRequest) GetPing() string {
	if x != nil {
		return x.Ping
	}
	return ""
}

type HeartbeatResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Pong is the response from the HydrAIDE server.
	// Often just echoes back a predefined value ("pong") for health check verification.
	Pong          string `protobuf:"bytes,1,opt,name=Pong,proto3" json:"Pong,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *HeartbeatResponse) Reset() {
	*x = HeartbeatResponse{}
	mi := &file_hydraide_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *HeartbeatResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*HeartbeatResponse) ProtoMessage() {}

func (x *HeartbeatResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use HeartbeatResponse.ProtoReflect.Descriptor instead.
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{1}
}

func (x *HeartbeatResponse) GetPong() string {
	if x != nil {
		return x.Pong
	}
	return ""
}

type LockRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the unique identifier for the lock.
	// Any client that wants to lock the same resource must use the same key.
	// This could represent a swamp name, a composite key, or a logical domain (e.g. "catalog-write-lock").
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// TTL is the time-to-live for the lock in milliseconds.
	// If the lock is not released within this period, it is automatically freed to avoid deadlocks.
	TTL           int64 `protobuf:"varint,2,opt,name=TTL,proto3" json:"TTL,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LockRequest) Reset() {
	*x = LockRequest{}
	mi := &file_hydraide_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockRequest) ProtoMessage() {}

func (x *LockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LockRequest.ProtoReflect.Descriptor instead.
func (*LockRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{2}
}

func (x *LockRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *LockRequest) GetTTL() int64 {
	if x != nil {
		return x.TTL
	}
	return 0
}

type LockResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// LockID is the unique token representing the granted lock instance.
	// This must be used in the corresponding Unlock request to release the lock.
	LockID        string `protobuf:"bytes,1,opt,name=LockID,proto3" json:"LockID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LockResponse) Reset() {
	*x = LockResponse{}
	mi := &file_hydraide_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockResponse) ProtoMessage() {}

func (x *LockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LockResponse.ProtoReflect.Descriptor instead.
func (*LockResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{3}
}

func (x *LockResponse) GetLockID() string {
	if x != nil {
		return x.LockID
	}
	return ""
}

type UnlockRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the same identifier used during locking.
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// LockID is the token returned by the Lock call.
	// Must match exactly in order to release the lock.
	LockID        string `protobuf:"bytes,2,opt,name=LockID,proto3" json:"LockID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnlockRequest) Reset() {
	*x = UnlockRequest{}
	mi := &file_hydraide_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnlockRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockRequest) ProtoMessage() {}

func (x *UnlockRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockRequest.ProtoReflect.Descriptor instead.
func (*UnlockRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{4}
}

func (x *UnlockRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *UnlockRequest) GetLockID() string {
	if x != nil {
		return x.LockID
	}
	return ""
}

type UnlockResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UnlockResponse) Reset() {
	*x = UnlockResponse{}
	mi := &file_hydraide_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UnlockResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UnlockResponse) ProtoMessage() {}

func (x *UnlockResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UnlockResponse.ProtoReflect.Descriptor instead.
func (*UnlockResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{5}
}

type DestroyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to be permanently deleted.
	//
	// This removes all treasures and metadata associated with the swamp.
	// Use with caution – this operation is irreversible.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestroyRequest) Reset() {
	*x = DestroyRequest{}
	mi := &file_hydraide_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestroyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestroyRequest) ProtoMessage() {}

func (x *DestroyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestroyRequest.ProtoReflect.Descriptor instead.
func (*DestroyRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{6}
}

func (x *DestroyRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *DestroyRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

type DestroyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DestroyResponse) Reset() {
	*x = DestroyResponse{}
	mi := &file_hydraide_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DestroyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DestroyResponse) ProtoMessage() {}

func (x *DestroyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DestroyResponse.ProtoReflect.Descriptor instead.
func (*DestroyResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{7}
}

type SubscribeToInfoRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to observe.
	//
	// The server will monitor this swamp and send realtime updates
	// whenever the number of treasures in it changes.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToInfoRequest) Reset() {
	*x = SubscribeToInfoRequest{}
	mi := &file_hydraide_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToInfoRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToInfoRequest) ProtoMessage() {}

func (x *SubscribeToInfoRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToInfoRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToInfoRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{8}
}

func (x *SubscribeToInfoRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *SubscribeToInfoRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

type SubscribeToInfoResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the name of the swamp the count refers to.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// AllElements is the current number of treasures in the swamp.
	//
	// This count is updated in real time as treasures are added, deleted, or expired.
	AllElements   uint64 `protobuf:"varint,2,opt,name=AllElements,proto3" json:"AllElements,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToInfoResponse) Reset() {
	*x = SubscribeToInfoResponse{}
	mi := &file_hydraide_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToInfoResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToInfoResponse) ProtoMessage() {}

func (x *SubscribeToInfoResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToInfoResponse.ProtoReflect.Descriptor instead.
func (*SubscribeToInfoResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{9}
}

func (x *SubscribeToInfoResponse) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *SubscribeToInfoResponse) GetAllElements() uint64 {
	if x != nil {
		return x.AllElements
	}
	return 0
}

type SubscribeToEventsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to subscribe to.
	//
	// All changes (insert, update, delete) in this swamp will be streamed in real time.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToEventsRequest) Reset() {
	*x = SubscribeToEventsRequest{}
	mi := &file_hydraide_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsRequest) ProtoMessage() {}

func (x *SubscribeToEventsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsRequest.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{10}
}

func (x *SubscribeToEventsRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *SubscribeToEventsRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

type SubscribeToEventsResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the swamp where the event occurred.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Treasure is the current value after the change (for NEW and UPDATED events).
	Treasure *Treasure `protobuf:"bytes,2,opt,name=Treasure,proto3" json:"Treasure,omitempty"`
	// OldTreasure is the previous value before the update (only for UPDATED events).
	// It will be empty for NEW or DELETE events.
	OldTreasure *Treasure `protobuf:"bytes,3,opt,name=OldTreasure,proto3" json:"OldTreasure,omitempty"`
	// DeletedTreasure is the removed value (only for DELETED events).
	// It will be empty for NEW and UPDATED events.
	DeletedTreasure *Treasure `protobuf:"bytes,4,opt,name=DeletedTreasure,proto3" json:"DeletedTreasure,omitempty"`
	// EventTime is the timestamp when the change happened (server-generated).
	EventTime *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=EventTime,proto3" json:"EventTime,omitempty"`
	// Status is the type of the event: NEW, UPDATED, DELETED, etc.
	Status        Status_Code `protobuf:"varint,6,opt,name=Status,proto3,enum=hydraidepbgo.Status_Code" json:"Status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SubscribeToEventsResponse) Reset() {
	*x = SubscribeToEventsResponse{}
	mi := &file_hydraide_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SubscribeToEventsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SubscribeToEventsResponse) ProtoMessage() {}

func (x *SubscribeToEventsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SubscribeToEventsResponse.ProtoReflect.Descriptor instead.
func (*SubscribeToEventsResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{11}
}

func (x *SubscribeToEventsResponse) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *SubscribeToEventsResponse) GetTreasure() *Treasure {
	if x != nil {
		return x.Treasure
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetOldTreasure() *Treasure {
	if x != nil {
		return x.OldTreasure
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetDeletedTreasure() *Treasure {
	if x != nil {
		return x.DeletedTreasure
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetEventTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EventTime
	}
	return nil
}

func (x *SubscribeToEventsResponse) GetStatus() Status_Code {
	if x != nil {
		return x.Status
	}
	return Status_NOT_FOUND
}

type SwampKeys struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the name of the swamp to operate on.
	//
	// All keys in this request belong to this one swamp.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Keys is the list of treasure keys we want to fetch, delete, or inspect.
	//
	// Used for batch operations like:
	// - Get multiple values
	// - Delete selected treasures
	// - Check key existence
	Keys          []string `protobuf:"bytes,2,rep,name=Keys,proto3" json:"Keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwampKeys) Reset() {
	*x = SwampKeys{}
	mi := &file_hydraide_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwampKeys) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwampKeys) ProtoMessage() {}

func (x *SwampKeys) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwampKeys.ProtoReflect.Descriptor instead.
func (*SwampKeys) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{12}
}

func (x *SwampKeys) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *SwampKeys) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

type RegisterSwampRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampPattern defines the full namespace of the swamp using the Sanctuary/Realm/Swamp pattern.
	//
	// Example: "search/hu/products"
	SwampPattern string `protobuf:"bytes,1,opt,name=SwampPattern,proto3" json:"SwampPattern,omitempty"`
	// CloseAfterIdle defines how long (in seconds) the swamp stays open after its last access.
	//
	// Once this timeout expires with no reads or writes, the swamp will be closed and flushed to disk.
	// This helps optimize memory usage for less-frequently accessed data.
	CloseAfterIdle int64 `protobuf:"varint,2,opt,name=CloseAfterIdle,proto3" json:"CloseAfterIdle,omitempty"`
	// IsInMemorySwamp determines whether the swamp should only exist in memory.
	//
	// If true: all data is kept in RAM (fast but volatile).
	// If false: data is persisted to disk (slower, but durable).
	IsInMemorySwamp bool `protobuf:"varint,3,opt,name=IsInMemorySwamp,proto3" json:"IsInMemorySwamp,omitempty"`
	// WriteInterval defines how often data should be flushed to disk, in seconds.
	//
	// Optional. Only applies when IsInMemorySwamp is false.
	// Lower values ensure better durability, higher values reduce I/O.
	WriteInterval *int64 `protobuf:"varint,4,opt,name=WriteInterval,proto3,oneof" json:"WriteInterval,omitempty"`
	// MaxFileSize sets the maximum size (in bytes) for a single compressed file chunk.
	//
	// Optional. Applies only when IsInMemorySwamp is false.
	// Useful for optimizing SSD usage and controlling compaction behavior.
	MaxFileSize   *int64 `protobuf:"varint,5,opt,name=MaxFileSize,proto3,oneof" json:"MaxFileSize,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterSwampRequest) Reset() {
	*x = RegisterSwampRequest{}
	mi := &file_hydraide_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterSwampRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterSwampRequest) ProtoMessage() {}

func (x *RegisterSwampRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterSwampRequest.ProtoReflect.Descriptor instead.
func (*RegisterSwampRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{13}
}

func (x *RegisterSwampRequest) GetSwampPattern() string {
	if x != nil {
		return x.SwampPattern
	}
	return ""
}

func (x *RegisterSwampRequest) GetCloseAfterIdle() int64 {
	if x != nil {
		return x.CloseAfterIdle
	}
	return 0
}

func (x *RegisterSwampRequest) GetIsInMemorySwamp() bool {
	if x != nil {
		return x.IsInMemorySwamp
	}
	return false
}

func (x *RegisterSwampRequest) GetWriteInterval() int64 {
	if x != nil && x.WriteInterval != nil {
		return *x.WriteInterval
	}
	return 0
}

func (x *RegisterSwampRequest) GetMaxFileSize() int64 {
	if x != nil && x.MaxFileSize != nil {
		return *x.MaxFileSize
	}
	return 0
}

type RegisterSwampResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RegisterSwampResponse) Reset() {
	*x = RegisterSwampResponse{}
	mi := &file_hydraide_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RegisterSwampResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RegisterSwampResponse) ProtoMessage() {}

func (x *RegisterSwampResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RegisterSwampResponse.ProtoReflect.Descriptor instead.
func (*RegisterSwampResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{14}
}

type DeRegisterSwampRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampPattern is the full namespace pattern of the swamp to remove from the active registry.
	//
	// ⚠️ Note: This does NOT delete the swamp or its data.
	// It only removes its configuration from the registry.
	SwampPattern  string `protobuf:"bytes,1,opt,name=SwampPattern,proto3" json:"SwampPattern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeRegisterSwampRequest) Reset() {
	*x = DeRegisterSwampRequest{}
	mi := &file_hydraide_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeRegisterSwampRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeRegisterSwampRequest) ProtoMessage() {}

func (x *DeRegisterSwampRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeRegisterSwampRequest.ProtoReflect.Descriptor instead.
func (*DeRegisterSwampRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{15}
}

func (x *DeRegisterSwampRequest) GetSwampPattern() string {
	if x != nil {
		return x.SwampPattern
	}
	return ""
}

type DeRegisterSwampResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeRegisterSwampResponse) Reset() {
	*x = DeRegisterSwampResponse{}
	mi := &file_hydraide_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeRegisterSwampResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeRegisterSwampResponse) ProtoMessage() {}

func (x *DeRegisterSwampResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeRegisterSwampResponse.ProtoReflect.Descriptor instead.
func (*DeRegisterSwampResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{16}
}

type SetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps is a list of write instructions, each targeting a specific swamp.
	//
	// You can insert or update multiple key-value pairs across multiple swamps in a single request.
	Swamps        []*SwampRequest `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetRequest) Reset() {
	*x = SetRequest{}
	mi := &file_hydraide_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetRequest) ProtoMessage() {}

func (x *SetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetRequest.ProtoReflect.Descriptor instead.
func (*SetRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{17}
}

func (x *SetRequest) GetSwamps() []*SwampRequest {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type SwampRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the globally consistent identifier of the "island" where this Swamp physically resides.
	//
	// An Island is a deterministic storage zone, derived from the full Swamp name
	// (Sanctuary / Realm / Swamp) using a fast hash function (e.g. xxhash).
	// The total number of Islands (i.e. hash slots) is fixed (e.g. 1000),
	// and each Swamp is anchored to exactly one Island based on its full name.
	//
	// 🏝️ What is an Island?
	// An Island is the smallest movable unit in the HydrAIDE system — a self-contained physical space
	// where one or many Swamps live. On disk, it maps to a top-level folder like: `/data/234/...`.
	//
	// 🌐 Why is this important?
	// This enables decentralized, orchestrator-free scaling:
	// - The client decides which Island a Swamp belongs to.
	// - The server simply accepts the IslandID and writes within that zone — it never hashes or routes.
	//
	// 🔁 How does this support scaling and migration?
	// Island-based partitioning allows you to:
	// - Move Swamps between servers without altering their names
	// - Keep servers stateless and swappable
	// - Perform migrations by just copying Island folders and updating client routing
	// - Avoid global rebalancing or coordination layers
	//
	// ✨ This design ensures:
	// - Deterministic Swamp placement
	// - Stateless and swappable servers
	// - Seamless, offline migration of data
	// - True horizontal scaling without any cluster manager
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the target swamp where the data should be written.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// KeyValues is the list of key-value pairs to insert or update in this swamp.
	KeyValues []*KeyValuePair `protobuf:"bytes,3,rep,name=KeyValues,proto3" json:"KeyValues,omitempty"`
	// CreateIfNotExist determines whether HydrAIDE should create the swamp and/or key if they don't exist yet.
	//
	// - true → create missing swamp and keys if needed (upsert)
	// - false → only allow updates to existing values
	CreateIfNotExist bool `protobuf:"varint,4,opt,name=CreateIfNotExist,proto3" json:"CreateIfNotExist,omitempty"`
	// Overwrite controls whether existing values should be replaced.
	//
	// - true → existing values will be overwritten
	// - false → existing values will remain untouched
	//
	// Combine this with CreateIfNotExist for fine-grained behavior:
	// - true + true = upsert
	// - false + true = update only
	// - true + false = insert only
	// - false + false = no-op (used for dry run / test)
	Overwrite     bool `protobuf:"varint,5,opt,name=Overwrite,proto3" json:"Overwrite,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwampRequest) Reset() {
	*x = SwampRequest{}
	mi := &file_hydraide_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwampRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwampRequest) ProtoMessage() {}

func (x *SwampRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwampRequest.ProtoReflect.Descriptor instead.
func (*SwampRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{18}
}

func (x *SwampRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *SwampRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *SwampRequest) GetKeyValues() []*KeyValuePair {
	if x != nil {
		return x.KeyValues
	}
	return nil
}

func (x *SwampRequest) GetCreateIfNotExist() bool {
	if x != nil {
		return x.CreateIfNotExist
	}
	return false
}

func (x *SwampRequest) GetOverwrite() bool {
	if x != nil {
		return x.Overwrite
	}
	return false
}

type KeyValuePair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the unique identifier of the treasure within the swamp.
	Key        string        `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	Int8Val    *int32        `protobuf:"varint,2,opt,name=Int8Val,proto3,oneof" json:"Int8Val,omitempty"`
	Int16Val   *int32        `protobuf:"varint,3,opt,name=Int16Val,proto3,oneof" json:"Int16Val,omitempty"`
	Int32Val   *int32        `protobuf:"varint,4,opt,name=Int32Val,proto3,oneof" json:"Int32Val,omitempty"`
	Int64Val   *int64        `protobuf:"varint,5,opt,name=Int64Val,proto3,oneof" json:"Int64Val,omitempty"`
	Uint8Val   *uint32       `protobuf:"varint,6,opt,name=Uint8Val,proto3,oneof" json:"Uint8Val,omitempty"`
	Uint16Val  *uint32       `protobuf:"varint,7,opt,name=Uint16Val,proto3,oneof" json:"Uint16Val,omitempty"`
	Uint32Val  *uint32       `protobuf:"varint,8,opt,name=Uint32Val,proto3,oneof" json:"Uint32Val,omitempty"`
	Uint64Val  *uint64       `protobuf:"varint,9,opt,name=Uint64Val,proto3,oneof" json:"Uint64Val,omitempty"`
	Float32Val *float32      `protobuf:"fixed32,10,opt,name=Float32Val,proto3,oneof" json:"Float32Val,omitempty"`
	Float64Val *float64      `protobuf:"fixed64,11,opt,name=Float64Val,proto3,oneof" json:"Float64Val,omitempty"`
	StringVal  *string       `protobuf:"bytes,12,opt,name=StringVal,proto3,oneof" json:"StringVal,omitempty"`
	BoolVal    *Boolean_Type `protobuf:"varint,13,opt,name=BoolVal,proto3,enum=hydraidepbgo.Boolean_Type,oneof" json:"BoolVal,omitempty"`
	BytesVal   []byte        `protobuf:"bytes,14,opt,name=BytesVal,proto3,oneof" json:"BytesVal,omitempty"`
	// Uint32Slice is a special set-like slice of uint32 values.
	//
	// It is deduplicated automatically by HydrAIDE: each number can only exist once.
	// Used for reverse indexes, relations, and ID mapping.
	Uint32Slice []uint32 `protobuf:"varint,15,rep,packed,name=Uint32Slice,proto3" json:"Uint32Slice,omitempty"`
	// VoidVal can be used to explicitly clear the value, without removing the key.
	//
	// If true:
	// - The treasure will be retained, but its content will be set to an empty/null value.
	// - Useful for clearing sensitive data or resetting state while keeping the key.
	//
	// 💡 Advanced use: You can use VoidVal to store keys without any associated value.
	// This is ideal for building key-only swamps (e.g. keyword sets, user tags, reverse indexes).
	// Such entries take **zero storage space** beyond the key itself.
	//
	// 🧠 Bonus: If you don't set CreatedAt / UpdatedAt / Metadata, HydrAIDE won't generate them either.
	// This keeps your swamp minimal and ultra-efficient when you don't need full metadata.
	VoidVal *bool `protobuf:"varint,16,opt,name=VoidVal,proto3,oneof" json:"VoidVal,omitempty"`
	// Metadata – these fields can be optionally set to override the system-generated timestamps.
	// Useful for syncing external sources or customizing indexing behavior.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=CreatedAt,proto3,oneof" json:"CreatedAt,omitempty"`
	CreatedBy *string                `protobuf:"bytes,18,opt,name=CreatedBy,proto3,oneof" json:"CreatedBy,omitempty"`
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=UpdatedAt,proto3,oneof" json:"UpdatedAt,omitempty"`
	UpdatedBy *string                `protobuf:"bytes,20,opt,name=UpdatedBy,proto3,oneof" json:"UpdatedBy,omitempty"`
	// ExpiredAt sets the expiration time for the treasure.
	//
	// If this field is set, HydrAIDE will treat the treasure as **expired** after the given timestamp.
	// Expired treasures remain accessible until explicitly queried or removed.
	//
	// 🔥 Powerful features unlocked with ExpiredAt:
	// - You can use `GetByIndex` with `EXPIRATION_TIME` to retrieve only expired (or not yet expired) entries.
	// - You can call `ShiftExpiredTreasures` to **extract and delete** expired items in a single atomic operation.
	// - Swamps can be organized like queues, schedules, or TTL-based caches using this field.
	//
	// 💡 If ExpiredAt is not set, the treasure will **never expire** automatically.
	ExpiredAt     *timestamppb.Timestamp `protobuf:"bytes,21,opt,name=ExpiredAt,proto3,oneof" json:"ExpiredAt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyValuePair) Reset() {
	*x = KeyValuePair{}
	mi := &file_hydraide_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyValuePair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyValuePair) ProtoMessage() {}

func (x *KeyValuePair) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyValuePair.ProtoReflect.Descriptor instead.
func (*KeyValuePair) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{19}
}

func (x *KeyValuePair) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyValuePair) GetInt8Val() int32 {
	if x != nil && x.Int8Val != nil {
		return *x.Int8Val
	}
	return 0
}

func (x *KeyValuePair) GetInt16Val() int32 {
	if x != nil && x.Int16Val != nil {
		return *x.Int16Val
	}
	return 0
}

func (x *KeyValuePair) GetInt32Val() int32 {
	if x != nil && x.Int32Val != nil {
		return *x.Int32Val
	}
	return 0
}

func (x *KeyValuePair) GetInt64Val() int64 {
	if x != nil && x.Int64Val != nil {
		return *x.Int64Val
	}
	return 0
}

func (x *KeyValuePair) GetUint8Val() uint32 {
	if x != nil && x.Uint8Val != nil {
		return *x.Uint8Val
	}
	return 0
}

func (x *KeyValuePair) GetUint16Val() uint32 {
	if x != nil && x.Uint16Val != nil {
		return *x.Uint16Val
	}
	return 0
}

func (x *KeyValuePair) GetUint32Val() uint32 {
	if x != nil && x.Uint32Val != nil {
		return *x.Uint32Val
	}
	return 0
}

func (x *KeyValuePair) GetUint64Val() uint64 {
	if x != nil && x.Uint64Val != nil {
		return *x.Uint64Val
	}
	return 0
}

func (x *KeyValuePair) GetFloat32Val() float32 {
	if x != nil && x.Float32Val != nil {
		return *x.Float32Val
	}
	return 0
}

func (x *KeyValuePair) GetFloat64Val() float64 {
	if x != nil && x.Float64Val != nil {
		return *x.Float64Val
	}
	return 0
}

func (x *KeyValuePair) GetStringVal() string {
	if x != nil && x.StringVal != nil {
		return *x.StringVal
	}
	return ""
}

func (x *KeyValuePair) GetBoolVal() Boolean_Type {
	if x != nil && x.BoolVal != nil {
		return *x.BoolVal
	}
	return Boolean_TRUE
}

func (x *KeyValuePair) GetBytesVal() []byte {
	if x != nil {
		return x.BytesVal
	}
	return nil
}

func (x *KeyValuePair) GetUint32Slice() []uint32 {
	if x != nil {
		return x.Uint32Slice
	}
	return nil
}

func (x *KeyValuePair) GetVoidVal() bool {
	if x != nil && x.VoidVal != nil {
		return *x.VoidVal
	}
	return false
}

func (x *KeyValuePair) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *KeyValuePair) GetCreatedBy() string {
	if x != nil && x.CreatedBy != nil {
		return *x.CreatedBy
	}
	return ""
}

func (x *KeyValuePair) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *KeyValuePair) GetUpdatedBy() string {
	if x != nil && x.UpdatedBy != nil {
		return *x.UpdatedBy
	}
	return ""
}

func (x *KeyValuePair) GetExpiredAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiredAt
	}
	return nil
}

type SetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps is a list of responses, one per swamp.
	Swamps        []*SwampResponse `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetResponse) Reset() {
	*x = SetResponse{}
	mi := &file_hydraide_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetResponse) ProtoMessage() {}

func (x *SetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetResponse.ProtoReflect.Descriptor instead.
func (*SetResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{20}
}

func (x *SetResponse) GetSwamps() []*SwampResponse {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type SwampResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the name of the swamp this response refers to.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// KeysAndStatuses contains the outcome of each key’s operation.
	KeysAndStatuses []*KeyStatusPair `protobuf:"bytes,2,rep,name=KeysAndStatuses,proto3" json:"KeysAndStatuses,omitempty"`
	// ErrorCode is set if the entire swamp operation failed.
	// (e.g., swamp doesn't exist and CreateIfNotExist was false)
	ErrorCode     *SwampResponse_ErrCodeEnum `protobuf:"varint,3,opt,name=ErrorCode,proto3,enum=hydraidepbgo.SwampResponse_ErrCodeEnum,oneof" json:"ErrorCode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SwampResponse) Reset() {
	*x = SwampResponse{}
	mi := &file_hydraide_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SwampResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SwampResponse) ProtoMessage() {}

func (x *SwampResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SwampResponse.ProtoReflect.Descriptor instead.
func (*SwampResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{21}
}

func (x *SwampResponse) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *SwampResponse) GetKeysAndStatuses() []*KeyStatusPair {
	if x != nil {
		return x.KeysAndStatuses
	}
	return nil
}

func (x *SwampResponse) GetErrorCode() SwampResponse_ErrCodeEnum {
	if x != nil && x.ErrorCode != nil {
		return *x.ErrorCode
	}
	return SwampResponse_CanNotBeExecuted
}

type KeyStatusPair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the identifier of the treasure.
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Status indicates what happened to the key during the Set operation.
	Status        Status_Code `protobuf:"varint,2,opt,name=Status,proto3,enum=hydraidepbgo.Status_Code" json:"Status,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeyStatusPair) Reset() {
	*x = KeyStatusPair{}
	mi := &file_hydraide_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeyStatusPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeyStatusPair) ProtoMessage() {}

func (x *KeyStatusPair) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeyStatusPair.ProtoReflect.Descriptor instead.
func (*KeyStatusPair) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{22}
}

func (x *KeyStatusPair) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyStatusPair) GetStatus() Status_Code {
	if x != nil {
		return x.Status
	}
	return Status_NOT_FOUND
}

type Status struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Status) Reset() {
	*x = Status{}
	mi := &file_hydraide_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Status) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Status) ProtoMessage() {}

func (x *Status) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Status.ProtoReflect.Descriptor instead.
func (*Status) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{23}
}

type GetRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps is a list of swamps with their associated keys to retrieve.
	//
	// You can batch multiple swamp/key combinations into a single request,
	// making the operation efficient for distributed or sharded datasets.
	//
	// Example:
	// - Swamp "hu/products" → get keys ["123", "456"]
	// - Swamp "de/users" → get keys ["alice", "bob"]
	Swamps        []*GetSwamp `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRequest) Reset() {
	*x = GetRequest{}
	mi := &file_hydraide_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRequest) ProtoMessage() {}

func (x *GetRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRequest.ProtoReflect.Descriptor instead.
func (*GetRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{24}
}

func (x *GetRequest) GetSwamps() []*GetSwamp {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type GetSwamp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to read from.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Keys is the list of treasure keys to retrieve from this swamp.
	Keys          []string `protobuf:"bytes,3,rep,name=Keys,proto3" json:"Keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSwamp) Reset() {
	*x = GetSwamp{}
	mi := &file_hydraide_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSwamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSwamp) ProtoMessage() {}

func (x *GetSwamp) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSwamp.ProtoReflect.Descriptor instead.
func (*GetSwamp) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{25}
}

func (x *GetSwamp) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *GetSwamp) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *GetSwamp) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

type GetResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps contains the result of each swamp that was queried.
	Swamps        []*GetSwampResponse `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResponse) Reset() {
	*x = GetResponse{}
	mi := &file_hydraide_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResponse) ProtoMessage() {}

func (x *GetResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResponse.ProtoReflect.Descriptor instead.
func (*GetResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{26}
}

func (x *GetResponse) GetSwamps() []*GetSwampResponse {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type GetSwampResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the swamp from which the treasures were returned.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// IsExist tells whether the swamp actually exists.
	//
	// If false, no data will be returned for this swamp.
	IsExist bool `protobuf:"varint,2,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	// Treasures contains the values of all successfully retrieved keys.
	// If a key did not exist, it will be omitted from the list.
	Treasures     []*Treasure `protobuf:"bytes,3,rep,name=Treasures,proto3" json:"Treasures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSwampResponse) Reset() {
	*x = GetSwampResponse{}
	mi := &file_hydraide_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSwampResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSwampResponse) ProtoMessage() {}

func (x *GetSwampResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSwampResponse.ProtoReflect.Descriptor instead.
func (*GetSwampResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{27}
}

func (x *GetSwampResponse) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *GetSwampResponse) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

func (x *GetSwampResponse) GetTreasures() []*Treasure {
	if x != nil {
		return x.Treasures
	}
	return nil
}

type GetAllRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp you want to retrieve all treasures from.
	//
	// HydrAIDE will return every key-value pair stored in this swamp, regardless of expiration or status.
	//
	// ⚠️ Caution: For large swamps, this can return a lot of data.
	// Consider using pagination or GetByIndex instead for better control.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAllRequest) Reset() {
	*x = GetAllRequest{}
	mi := &file_hydraide_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAllRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAllRequest) ProtoMessage() {}

func (x *GetAllRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAllRequest.ProtoReflect.Descriptor instead.
func (*GetAllRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{28}
}

func (x *GetAllRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *GetAllRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

type GetAllResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Treasures contains all key-value pairs from the requested swamp.
	//
	// Each Treasure includes its key, type-specific value, metadata (if any),
	// and its current existence status.
	//
	// 💡 Useful for:
	// - Initial snapshot generation
	// - Manual data inspection
	// - Rebuilding in-memory views or local caches
	Treasures     []*Treasure `protobuf:"bytes,1,rep,name=Treasures,proto3" json:"Treasures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAllResponse) Reset() {
	*x = GetAllResponse{}
	mi := &file_hydraide_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAllResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAllResponse) ProtoMessage() {}

func (x *GetAllResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAllResponse.ProtoReflect.Descriptor instead.
func (*GetAllResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{29}
}

func (x *GetAllResponse) GetTreasures() []*Treasure {
	if x != nil {
		return x.Treasures
	}
	return nil
}

type ShiftExpiredTreasuresRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp you want to shift expired treasures from.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// HowMany defines how many expired treasures should be returned and deleted.
	//
	// - If set to 0 → HydrAIDE will return **all** expired entries from the swamp.
	// - If greater than 0 → only the specified number of expired treasures will be returned.
	//
	// ⚠️ Note: This operation is destructive – the shifted treasures will be removed immediately.
	HowMany       int32 `protobuf:"varint,3,opt,name=HowMany,proto3" json:"HowMany,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShiftExpiredTreasuresRequest) Reset() {
	*x = ShiftExpiredTreasuresRequest{}
	mi := &file_hydraide_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShiftExpiredTreasuresRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShiftExpiredTreasuresRequest) ProtoMessage() {}

func (x *ShiftExpiredTreasuresRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShiftExpiredTreasuresRequest.ProtoReflect.Descriptor instead.
func (*ShiftExpiredTreasuresRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{30}
}

func (x *ShiftExpiredTreasuresRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *ShiftExpiredTreasuresRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *ShiftExpiredTreasuresRequest) GetHowMany() int32 {
	if x != nil {
		return x.HowMany
	}
	return 0
}

type ShiftExpiredTreasuresResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Treasures contains the expired entries that were retrieved and deleted from the swamp.
	//
	// Each treasure includes its key, value, and metadata at the time of expiration.
	//
	// 🔔 Realtime: These deletions will also trigger `SubscribeToEvents` notifications.
	Treasures     []*Treasure `protobuf:"bytes,1,rep,name=Treasures,proto3" json:"Treasures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ShiftExpiredTreasuresResponse) Reset() {
	*x = ShiftExpiredTreasuresResponse{}
	mi := &file_hydraide_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ShiftExpiredTreasuresResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ShiftExpiredTreasuresResponse) ProtoMessage() {}

func (x *ShiftExpiredTreasuresResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ShiftExpiredTreasuresResponse.ProtoReflect.Descriptor instead.
func (*ShiftExpiredTreasuresResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{31}
}

func (x *ShiftExpiredTreasuresResponse) GetTreasures() []*Treasure {
	if x != nil {
		return x.Treasures
	}
	return nil
}

type Treasure struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key is the unique identifier of the treasure within the swamp.
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// IsExist indicates whether the treasure was actually found in the swamp.
	//
	// If false:
	// - The treasure was requested, but does not exist.
	// - All value and metadata fields will be unset.
	IsExist    bool          `protobuf:"varint,2,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	Int8Val    *int32        `protobuf:"varint,3,opt,name=Int8Val,proto3,oneof" json:"Int8Val,omitempty"`
	Int16Val   *int32        `protobuf:"varint,4,opt,name=Int16Val,proto3,oneof" json:"Int16Val,omitempty"`
	Int32Val   *int32        `protobuf:"varint,5,opt,name=Int32Val,proto3,oneof" json:"Int32Val,omitempty"`
	Int64Val   *int64        `protobuf:"varint,6,opt,name=Int64Val,proto3,oneof" json:"Int64Val,omitempty"`
	Uint8Val   *uint32       `protobuf:"varint,7,opt,name=Uint8Val,proto3,oneof" json:"Uint8Val,omitempty"`
	Uint16Val  *uint32       `protobuf:"varint,8,opt,name=Uint16Val,proto3,oneof" json:"Uint16Val,omitempty"`
	Uint32Val  *uint32       `protobuf:"varint,9,opt,name=Uint32Val,proto3,oneof" json:"Uint32Val,omitempty"`
	Uint64Val  *uint64       `protobuf:"varint,10,opt,name=Uint64Val,proto3,oneof" json:"Uint64Val,omitempty"`
	Float32Val *float32      `protobuf:"fixed32,11,opt,name=Float32Val,proto3,oneof" json:"Float32Val,omitempty"`
	Float64Val *float64      `protobuf:"fixed64,12,opt,name=Float64Val,proto3,oneof" json:"Float64Val,omitempty"`
	StringVal  *string       `protobuf:"bytes,13,opt,name=StringVal,proto3,oneof" json:"StringVal,omitempty"`
	BoolVal    *Boolean_Type `protobuf:"varint,14,opt,name=BoolVal,proto3,enum=hydraidepbgo.Boolean_Type,oneof" json:"BoolVal,omitempty"`
	BytesVal   []byte        `protobuf:"bytes,15,opt,name=BytesVal,proto3,oneof" json:"BytesVal,omitempty"`
	// Uint32Slice is a special, automatically deduplicated list of uint32 values.
	//
	// Ideal for storing IDs, reverse indexes, or permission sets.
	Uint32Slice []uint32 `protobuf:"varint,16,rep,packed,name=Uint32Slice,proto3" json:"Uint32Slice,omitempty"`
	// CreatedAt is the timestamp when the treasure was first created.
	//
	// ⚠️ HydrAIDE does not generate this automatically.
	// This field will only be present if you explicitly set it during the Set operation.
	CreatedAt *timestamppb.Timestamp `protobuf:"bytes,17,opt,name=CreatedAt,proto3,oneof" json:"CreatedAt,omitempty"`
	// CreatedBy stores the identifier (user/system) that created the treasure.
	//
	// ⚠️ Optional. Only stored if provided at write time.
	CreatedBy *string `protobuf:"bytes,18,opt,name=CreatedBy,proto3,oneof" json:"CreatedBy,omitempty"`
	// UpdatedAt is the last modification timestamp of the treasure.
	//
	// ⚠️ Optional. HydrAIDE won't auto-populate this — you must set it manually if needed.
	UpdatedAt *timestamppb.Timestamp `protobuf:"bytes,19,opt,name=UpdatedAt,proto3,oneof" json:"UpdatedAt,omitempty"`
	// UpdatedBy stores the identifier of who last modified the treasure.
	//
	// ⚠️ Optional. Set it explicitly in the Set request if tracking is desired.
	UpdatedBy *string `protobuf:"bytes,20,opt,name=UpdatedBy,proto3,oneof" json:"UpdatedBy,omitempty"`
	// ExpiredAt defines the expiration time for the treasure.
	//
	// After this time, the treasure is considered expired and can be retrieved or removed using:
	// - `GetByIndex` with `EXPIRATION_TIME`
	// - `ShiftExpiredTreasures`
	//
	// ⚠️ Important: HydrAIDE does NOT auto-generate this value.
	// If you want a treasure to expire, you must set ExpiredAt yourself during the `Set` operation.
	//
	// If ExpiredAt is not set:
	// - The treasure is considered to never expire
	// - It will not appear in expiration-based queries
	ExpiredAt     *timestamppb.Timestamp `protobuf:"bytes,21,opt,name=ExpiredAt,proto3,oneof" json:"ExpiredAt,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Treasure) Reset() {
	*x = Treasure{}
	mi := &file_hydraide_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Treasure) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Treasure) ProtoMessage() {}

func (x *Treasure) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Treasure.ProtoReflect.Descriptor instead.
func (*Treasure) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{32}
}

func (x *Treasure) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Treasure) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

func (x *Treasure) GetInt8Val() int32 {
	if x != nil && x.Int8Val != nil {
		return *x.Int8Val
	}
	return 0
}

func (x *Treasure) GetInt16Val() int32 {
	if x != nil && x.Int16Val != nil {
		return *x.Int16Val
	}
	return 0
}

func (x *Treasure) GetInt32Val() int32 {
	if x != nil && x.Int32Val != nil {
		return *x.Int32Val
	}
	return 0
}

func (x *Treasure) GetInt64Val() int64 {
	if x != nil && x.Int64Val != nil {
		return *x.Int64Val
	}
	return 0
}

func (x *Treasure) GetUint8Val() uint32 {
	if x != nil && x.Uint8Val != nil {
		return *x.Uint8Val
	}
	return 0
}

func (x *Treasure) GetUint16Val() uint32 {
	if x != nil && x.Uint16Val != nil {
		return *x.Uint16Val
	}
	return 0
}

func (x *Treasure) GetUint32Val() uint32 {
	if x != nil && x.Uint32Val != nil {
		return *x.Uint32Val
	}
	return 0
}

func (x *Treasure) GetUint64Val() uint64 {
	if x != nil && x.Uint64Val != nil {
		return *x.Uint64Val
	}
	return 0
}

func (x *Treasure) GetFloat32Val() float32 {
	if x != nil && x.Float32Val != nil {
		return *x.Float32Val
	}
	return 0
}

func (x *Treasure) GetFloat64Val() float64 {
	if x != nil && x.Float64Val != nil {
		return *x.Float64Val
	}
	return 0
}

func (x *Treasure) GetStringVal() string {
	if x != nil && x.StringVal != nil {
		return *x.StringVal
	}
	return ""
}

func (x *Treasure) GetBoolVal() Boolean_Type {
	if x != nil && x.BoolVal != nil {
		return *x.BoolVal
	}
	return Boolean_TRUE
}

func (x *Treasure) GetBytesVal() []byte {
	if x != nil {
		return x.BytesVal
	}
	return nil
}

func (x *Treasure) GetUint32Slice() []uint32 {
	if x != nil {
		return x.Uint32Slice
	}
	return nil
}

func (x *Treasure) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *Treasure) GetCreatedBy() string {
	if x != nil && x.CreatedBy != nil {
		return *x.CreatedBy
	}
	return ""
}

func (x *Treasure) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *Treasure) GetUpdatedBy() string {
	if x != nil && x.UpdatedBy != nil {
		return *x.UpdatedBy
	}
	return ""
}

func (x *Treasure) GetExpiredAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiredAt
	}
	return nil
}

type Boolean struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Boolean) Reset() {
	*x = Boolean{}
	mi := &file_hydraide_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Boolean) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Boolean) ProtoMessage() {}

func (x *Boolean) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Boolean.ProtoReflect.Descriptor instead.
func (*Boolean) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{33}
}

type GetByIndexRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to query.
	//
	// The index will be built in memory for this swamp at query time.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// IndexType specifies which field to index and query on.
	//
	// Supported indexes:
	// - KEY → Sort alphabetically by key
	// - EXPIRATION_TIME → Query based on ExpiredAt timestamps
	// - CREATION_TIME → Query based on CreatedAt timestamps
	// - UPDATE_TIME → Query based on UpdatedAt timestamps
	// - VALUE_* → Query by the actual value (e.g., int, string, float)
	IndexType IndexType_Type `protobuf:"varint,3,opt,name=IndexType,proto3,enum=hydraidepbgo.IndexType_Type" json:"IndexType,omitempty"`
	// OrderType defines the sort direction:
	// - ASC → Oldest/smallest first
	// - DESC → Newest/largest first
	OrderType OrderType_Type `protobuf:"varint,4,opt,name=OrderType,proto3,enum=hydraidepbgo.OrderType_Type" json:"OrderType,omitempty"`
	// From defines the starting index (zero-based).
	//
	// Use it for pagination or skipping elements.
	// Set to 0 to start from the beginning.
	From int32 `protobuf:"varint,5,opt,name=From,proto3" json:"From,omitempty"`
	// Limit defines how many items to return.
	//
	// Set to 0 to return all results (⚠️ caution on large datasets).
	Limit         int32 `protobuf:"varint,6,opt,name=Limit,proto3" json:"Limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByIndexRequest) Reset() {
	*x = GetByIndexRequest{}
	mi := &file_hydraide_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByIndexRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByIndexRequest) ProtoMessage() {}

func (x *GetByIndexRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByIndexRequest.ProtoReflect.Descriptor instead.
func (*GetByIndexRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{34}
}

func (x *GetByIndexRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *GetByIndexRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *GetByIndexRequest) GetIndexType() IndexType_Type {
	if x != nil {
		return x.IndexType
	}
	return IndexType_KEY
}

func (x *GetByIndexRequest) GetOrderType() OrderType_Type {
	if x != nil {
		return x.OrderType
	}
	return OrderType_ASC
}

func (x *GetByIndexRequest) GetFrom() int32 {
	if x != nil {
		return x.From
	}
	return 0
}

func (x *GetByIndexRequest) GetLimit() int32 {
	if x != nil {
		return x.Limit
	}
	return 0
}

type IndexType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexType) Reset() {
	*x = IndexType{}
	mi := &file_hydraide_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexType) ProtoMessage() {}

func (x *IndexType) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexType.ProtoReflect.Descriptor instead.
func (*IndexType) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{35}
}

type OrderType struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OrderType) Reset() {
	*x = OrderType{}
	mi := &file_hydraide_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OrderType) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OrderType) ProtoMessage() {}

func (x *OrderType) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OrderType.ProtoReflect.Descriptor instead.
func (*OrderType) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{36}
}

type GetByIndexResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Treasures contains the list of key-value pairs sorted and filtered
	// according to the request's index and parameters.
	Treasures     []*Treasure `protobuf:"bytes,1,rep,name=Treasures,proto3" json:"Treasures,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetByIndexResponse) Reset() {
	*x = GetByIndexResponse{}
	mi := &file_hydraide_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetByIndexResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetByIndexResponse) ProtoMessage() {}

func (x *GetByIndexResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetByIndexResponse.ProtoReflect.Descriptor instead.
func (*GetByIndexResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{37}
}

func (x *GetByIndexResponse) GetTreasures() []*Treasure {
	if x != nil {
		return x.Treasures
	}
	return nil
}

type DeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps contains one or more swamp/key combinations for deletion.
	//
	// You can batch-delete multiple keys from multiple swamps in a single request.
	Swamps        []*DeleteRequest_SwampKeys `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest) Reset() {
	*x = DeleteRequest{}
	mi := &file_hydraide_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest) ProtoMessage() {}

func (x *DeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest.ProtoReflect.Descriptor instead.
func (*DeleteRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{38}
}

func (x *DeleteRequest) GetSwamps() []*DeleteRequest_SwampKeys {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type DeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Responses holds the result of the delete operations, swamp by swamp.
	Responses     []*DeleteResponse_SwampDeleteResponse `protobuf:"bytes,1,rep,name=Responses,proto3" json:"Responses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse) Reset() {
	*x = DeleteResponse{}
	mi := &file_hydraide_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse) ProtoMessage() {}

func (x *DeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{39}
}

func (x *DeleteResponse) GetResponses() []*DeleteResponse_SwampDeleteResponse {
	if x != nil {
		return x.Responses
	}
	return nil
}

type CountRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampNames is the list of swamps you want to inspect.
	//
	// You can count multiple swamps at once.
	Swamps        []*CountRequest_SwampIdentifier `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CountRequest) Reset() {
	*x = CountRequest{}
	mi := &file_hydraide_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CountRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CountRequest) ProtoMessage() {}

func (x *CountRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CountRequest.ProtoReflect.Descriptor instead.
func (*CountRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{40}
}

func (x *CountRequest) GetSwamps() []*CountRequest_SwampIdentifier {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type CountResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Swamps contains the count result for each swamp queried.
	Swamps        []*CountSwamp `protobuf:"bytes,1,rep,name=Swamps,proto3" json:"Swamps,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CountResponse) Reset() {
	*x = CountResponse{}
	mi := &file_hydraide_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CountResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CountResponse) ProtoMessage() {}

func (x *CountResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CountResponse.ProtoReflect.Descriptor instead.
func (*CountResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{41}
}

func (x *CountResponse) GetSwamps() []*CountSwamp {
	if x != nil {
		return x.Swamps
	}
	return nil
}

type CountSwamp struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the name of the swamp counted.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// IsExist tells whether the swamp exists in the system.
	IsExist bool `protobuf:"varint,2,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	// Count is the number of treasures currently stored in this swamp.
	Count         int32 `protobuf:"varint,3,opt,name=Count,proto3" json:"Count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CountSwamp) Reset() {
	*x = CountSwamp{}
	mi := &file_hydraide_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CountSwamp) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CountSwamp) ProtoMessage() {}

func (x *CountSwamp) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CountSwamp.ProtoReflect.Descriptor instead.
func (*CountSwamp) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{42}
}

func (x *CountSwamp) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *CountSwamp) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

func (x *CountSwamp) GetCount() int32 {
	if x != nil {
		return x.Count
	}
	return 0
}

type IncrementRequestMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CreatedAt     *bool                  `protobuf:"varint,1,opt,name=CreatedAt,proto3,oneof" json:"CreatedAt,omitempty"` // If true, the CreatedAt timestamp will be set to the current time
	CreatedBy     *string                `protobuf:"bytes,2,opt,name=CreatedBy,proto3,oneof" json:"CreatedBy,omitempty"`  // If set, the CreatedBy field will be set to this value
	UpdatedAt     *bool                  `protobuf:"varint,3,opt,name=UpdatedAt,proto3,oneof" json:"UpdatedAt,omitempty"` // If true, the UpdatedAt timestamp will be set to the current time
	UpdatedBy     *string                `protobuf:"bytes,4,opt,name=UpdatedBy,proto3,oneof" json:"UpdatedBy,omitempty"`  // If set, the UpdatedBy field will be set to this value
	ExpiredAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=ExpiredAt,proto3,oneof" json:"ExpiredAt,omitempty"`  // If set, the expireAt field will be set to this value
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementRequestMetadata) Reset() {
	*x = IncrementRequestMetadata{}
	mi := &file_hydraide_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementRequestMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementRequestMetadata) ProtoMessage() {}

func (x *IncrementRequestMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementRequestMetadata.ProtoReflect.Descriptor instead.
func (*IncrementRequestMetadata) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{43}
}

func (x *IncrementRequestMetadata) GetCreatedAt() bool {
	if x != nil && x.CreatedAt != nil {
		return *x.CreatedAt
	}
	return false
}

func (x *IncrementRequestMetadata) GetCreatedBy() string {
	if x != nil && x.CreatedBy != nil {
		return *x.CreatedBy
	}
	return ""
}

func (x *IncrementRequestMetadata) GetUpdatedAt() bool {
	if x != nil && x.UpdatedAt != nil {
		return *x.UpdatedAt
	}
	return false
}

func (x *IncrementRequestMetadata) GetUpdatedBy() string {
	if x != nil && x.UpdatedBy != nil {
		return *x.UpdatedBy
	}
	return ""
}

func (x *IncrementRequestMetadata) GetExpiredAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiredAt
	}
	return nil
}

type IncrementResponseMetadata struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	CreatedAt     *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=CreatedAt,proto3,oneof" json:"CreatedAt,omitempty"` // The timestamp when the treasure was created
	CreatedBy     *string                `protobuf:"bytes,2,opt,name=CreatedBy,proto3,oneof" json:"CreatedBy,omitempty"` // The identifier of who created the treasure
	UpdatedAt     *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=UpdatedAt,proto3,oneof" json:"UpdatedAt,omitempty"` // The timestamp when the treasure was last
	UpdatedBy     *string                `protobuf:"bytes,4,opt,name=UpdatedBy,proto3,oneof" json:"UpdatedBy,omitempty"` // The identifier of who last updated the treasure
	ExpiredAt     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=ExpiredAt,proto3,oneof" json:"ExpiredAt,omitempty"` // The timestamp when the treasure will expire
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementResponseMetadata) Reset() {
	*x = IncrementResponseMetadata{}
	mi := &file_hydraide_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementResponseMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementResponseMetadata) ProtoMessage() {}

func (x *IncrementResponseMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementResponseMetadata.ProtoReflect.Descriptor instead.
func (*IncrementResponseMetadata) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{44}
}

func (x *IncrementResponseMetadata) GetCreatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.CreatedAt
	}
	return nil
}

func (x *IncrementResponseMetadata) GetCreatedBy() string {
	if x != nil && x.CreatedBy != nil {
		return *x.CreatedBy
	}
	return ""
}

func (x *IncrementResponseMetadata) GetUpdatedAt() *timestamppb.Timestamp {
	if x != nil {
		return x.UpdatedAt
	}
	return nil
}

func (x *IncrementResponseMetadata) GetUpdatedBy() string {
	if x != nil && x.UpdatedBy != nil {
		return *x.UpdatedBy
	}
	return ""
}

func (x *IncrementResponseMetadata) GetExpiredAt() *timestamppb.Timestamp {
	if x != nil {
		return x.ExpiredAt
	}
	return nil
}

type IncrementInt8Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the value resides.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the identifier of the treasure to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the signed integer to add (or subtract) from the current value.
	//
	// ⚠️ Although this is declared as int32, only int8-range values are stored.
	// HydrAIDE internally converts and enforces the correct range.
	//
	// 💡 Supports negative values for decrementing.
	IncrementBy int32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition determines whether the increment should proceed.
	Condition *IncrementInt8Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt8Request) Reset() {
	*x = IncrementInt8Request{}
	mi := &file_hydraide_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt8Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt8Request) ProtoMessage() {}

func (x *IncrementInt8Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt8Request.ProtoReflect.Descriptor instead.
func (*IncrementInt8Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{45}
}

func (x *IncrementInt8Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementInt8Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementInt8Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementInt8Request) GetIncrementBy() int32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementInt8Request) GetCondition() *IncrementInt8Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementInt8Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementInt8Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementInt8Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relational operator to apply (e.g., GREATER_THAN, EQUAL).
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The value to compare against.
	//
	// ⚠️ Despite being int32 here (due to proto3 limitation), only valid int8 values are considered.
	Value         int32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt8Condition) Reset() {
	*x = IncrementInt8Condition{}
	mi := &file_hydraide_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt8Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt8Condition) ProtoMessage() {}

func (x *IncrementInt8Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt8Condition.ProtoReflect.Descriptor instead.
func (*IncrementInt8Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{46}
}

func (x *IncrementInt8Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementInt8Condition) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementInt8Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting value after the increment (or original if unchanged).
	//
	// Note: ⚠️ This is represented as int32 due to proto3 constraints,
	// but internally HydrAIDE uses int8 precision and guarantees type-safety.
	Value int32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented indicates whether the increment was actually applied.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt8Response) Reset() {
	*x = IncrementInt8Response{}
	mi := &file_hydraide_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt8Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt8Response) ProtoMessage() {}

func (x *IncrementInt8Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt8Response.ProtoReflect.Descriptor instead.
func (*IncrementInt8Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{47}
}

func (x *IncrementInt8Response) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementInt8Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementInt8Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementInt16Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the value resides.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the identifier of the treasure to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the signed integer to add (or subtract) from the current value.
	//
	// ⚠️ Although this is declared as int32, HydrAIDE stores the value as int16.
	// The system enforces proper bounds and type conversion internally.
	IncrementBy int32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition determines whether the increment should proceed.
	Condition *IncrementInt16Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt16Request) Reset() {
	*x = IncrementInt16Request{}
	mi := &file_hydraide_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt16Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt16Request) ProtoMessage() {}

func (x *IncrementInt16Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt16Request.ProtoReflect.Descriptor instead.
func (*IncrementInt16Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{48}
}

func (x *IncrementInt16Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementInt16Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementInt16Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementInt16Request) GetIncrementBy() int32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementInt16Request) GetCondition() *IncrementInt16Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementInt16Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementInt16Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementInt16Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relational operator to apply (e.g., GREATER_THAN, LESS_THAN).
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The value to compare against.
	//
	// ⚠️ While represented as int32 (due to proto3 constraints),
	// HydrAIDE treats it as an int16 behind the scenes.
	Value         int32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt16Condition) Reset() {
	*x = IncrementInt16Condition{}
	mi := &file_hydraide_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt16Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt16Condition) ProtoMessage() {}

func (x *IncrementInt16Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt16Condition.ProtoReflect.Descriptor instead.
func (*IncrementInt16Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{49}
}

func (x *IncrementInt16Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementInt16Condition) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementInt16Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting value after incrementing.
	//
	// Note: Represented as int32 for compatibility, but HydrAIDE ensures
	// that the underlying type remains int16 and no data loss occurs.
	Value int32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented tells whether the value was actually modified.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt16Response) Reset() {
	*x = IncrementInt16Response{}
	mi := &file_hydraide_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt16Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt16Response) ProtoMessage() {}

func (x *IncrementInt16Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt16Response.ProtoReflect.Descriptor instead.
func (*IncrementInt16Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{50}
}

func (x *IncrementInt16Response) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementInt16Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementInt16Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementInt32Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the value resides.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the treasure key whose value we want to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the signed 32-bit integer to add or subtract.
	IncrementBy int32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition must be satisfied for the increment to apply.
	Condition *IncrementInt32Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt32Request) Reset() {
	*x = IncrementInt32Request{}
	mi := &file_hydraide_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt32Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt32Request) ProtoMessage() {}

func (x *IncrementInt32Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt32Request.ProtoReflect.Descriptor instead.
func (*IncrementInt32Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{51}
}

func (x *IncrementInt32Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementInt32Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementInt32Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementInt32Request) GetIncrementBy() int32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementInt32Request) GetCondition() *IncrementInt32Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementInt32Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementInt32Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementInt32Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relational operator for evaluating the current value.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// Value to compare against (int32).
	Value         int32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt32Condition) Reset() {
	*x = IncrementInt32Condition{}
	mi := &file_hydraide_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt32Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt32Condition) ProtoMessage() {}

func (x *IncrementInt32Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt32Condition.ProtoReflect.Descriptor instead.
func (*IncrementInt32Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{52}
}

func (x *IncrementInt32Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementInt32Condition) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementInt32Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting int32 value after increment.
	Value int32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented is true if the value was changed.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt32Response) Reset() {
	*x = IncrementInt32Response{}
	mi := &file_hydraide_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt32Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt32Response) ProtoMessage() {}

func (x *IncrementInt32Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt32Response.ProtoReflect.Descriptor instead.
func (*IncrementInt32Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{53}
}

func (x *IncrementInt32Response) GetValue() int32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementInt32Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementInt32Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementInt64Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the treasure is stored.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key identifies the treasure you want to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the signed 64-bit integer to add (can be negative).
	//
	// 💡 Ideal for working with timestamps, counters, large numeric values.
	IncrementBy int64 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition must be met for the increment to happen.
	Condition *IncrementInt64Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt64Request) Reset() {
	*x = IncrementInt64Request{}
	mi := &file_hydraide_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt64Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt64Request) ProtoMessage() {}

func (x *IncrementInt64Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt64Request.ProtoReflect.Descriptor instead.
func (*IncrementInt64Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{54}
}

func (x *IncrementInt64Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementInt64Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementInt64Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementInt64Request) GetIncrementBy() int64 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementInt64Request) GetCondition() *IncrementInt64Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementInt64Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementInt64Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementInt64Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Relational operator used for conditional increment.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The reference value to compare the current value against.
	Value         int64 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt64Condition) Reset() {
	*x = IncrementInt64Condition{}
	mi := &file_hydraide_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt64Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt64Condition) ProtoMessage() {}

func (x *IncrementInt64Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt64Condition.ProtoReflect.Descriptor instead.
func (*IncrementInt64Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{55}
}

func (x *IncrementInt64Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementInt64Condition) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementInt64Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting value after the increment (or the original value if condition failed).
	Value int64 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented indicates whether the operation was applied.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementInt64Response) Reset() {
	*x = IncrementInt64Response{}
	mi := &file_hydraide_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementInt64Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementInt64Response) ProtoMessage() {}

func (x *IncrementInt64Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementInt64Response.ProtoReflect.Descriptor instead.
func (*IncrementInt64Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{56}
}

func (x *IncrementInt64Response) GetValue() int64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementInt64Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementInt64Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementUint8Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName identifies the swamp where the treasure lives.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the treasure to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the unsigned integer to add to the current value.
	//
	// ⚠️ Although represented as uint32 due to proto3 limitations,
	// HydrAIDE stores this as a true uint8 internally (0–255).
	//
	// Any overflow is safely rejected and not applied.
	IncrementBy uint32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition to be evaluated before applying the increment.
	Condition *IncrementUint8Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint8Request) Reset() {
	*x = IncrementUint8Request{}
	mi := &file_hydraide_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint8Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint8Request) ProtoMessage() {}

func (x *IncrementUint8Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint8Request.ProtoReflect.Descriptor instead.
func (*IncrementUint8Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{57}
}

func (x *IncrementUint8Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementUint8Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementUint8Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementUint8Request) GetIncrementBy() uint32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementUint8Request) GetCondition() *IncrementUint8Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementUint8Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementUint8Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementUint8Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relational operator (e.g. EQUAL, GREATER_THAN, etc.)
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// Value to compare against before incrementing.
	//
	// ⚠️ Same as above: Only values within the uint8 range are accepted internally.
	Value         uint32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint8Condition) Reset() {
	*x = IncrementUint8Condition{}
	mi := &file_hydraide_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint8Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint8Condition) ProtoMessage() {}

func (x *IncrementUint8Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint8Condition.ProtoReflect.Descriptor instead.
func (*IncrementUint8Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{58}
}

func (x *IncrementUint8Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementUint8Condition) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementUint8Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting value after increment.
	//
	// ⚠️ Represented as uint32 in the response, but internally it's stored as uint8.
	Value uint32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented is true if the increment was applied.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint8Response) Reset() {
	*x = IncrementUint8Response{}
	mi := &file_hydraide_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint8Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint8Response) ProtoMessage() {}

func (x *IncrementUint8Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint8Response.ProtoReflect.Descriptor instead.
func (*IncrementUint8Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{59}
}

func (x *IncrementUint8Response) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementUint8Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementUint8Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementUint16Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the treasure is stored.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key identifies the target treasure.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the unsigned integer to add (or subtract, if allowed).
	//
	// ⚠️ Represented as `uint32` in the gRPC interface, but HydrAIDE stores it as true `uint16` internally.
	// Allowed value range: 0 to 65,535
	IncrementBy uint32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition to be satisfied before increment is applied.
	Condition *IncrementUint16Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint16Request) Reset() {
	*x = IncrementUint16Request{}
	mi := &file_hydraide_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint16Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint16Request) ProtoMessage() {}

func (x *IncrementUint16Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint16Request.ProtoReflect.Descriptor instead.
func (*IncrementUint16Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{60}
}

func (x *IncrementUint16Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementUint16Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementUint16Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementUint16Request) GetIncrementBy() uint32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementUint16Request) GetCondition() *IncrementUint16Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementUint16Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementUint16Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementUint16Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The logical operator used for evaluating the current value.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// Comparison reference value.
	//
	// ⚠️ Although this is a `uint32`, HydrAIDE handles it as `uint16` internally.
	Value         uint32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint16Condition) Reset() {
	*x = IncrementUint16Condition{}
	mi := &file_hydraide_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint16Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint16Condition) ProtoMessage() {}

func (x *IncrementUint16Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint16Condition.ProtoReflect.Descriptor instead.
func (*IncrementUint16Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{61}
}

func (x *IncrementUint16Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementUint16Condition) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementUint16Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the final (or original) value after attempted increment.
	//
	// Still represented as `uint32` due to proto limitations, but only 0..65535 values are stored.
	Value uint32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented tells whether the value was actually modified.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint16Response) Reset() {
	*x = IncrementUint16Response{}
	mi := &file_hydraide_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint16Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint16Response) ProtoMessage() {}

func (x *IncrementUint16Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint16Response.ProtoReflect.Descriptor instead.
func (*IncrementUint16Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{62}
}

func (x *IncrementUint16Response) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementUint16Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementUint16Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementUint32Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName specifies the target swamp.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key identifies the treasure to increment.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the unsigned 32-bit integer value to add.
	//
	// 💡 Supports any uint32 value (0–4,294,967,295)
	IncrementBy uint32 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition must be true for the increment to be applied.
	Condition *IncrementUint32Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint32Request) Reset() {
	*x = IncrementUint32Request{}
	mi := &file_hydraide_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint32Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint32Request) ProtoMessage() {}

func (x *IncrementUint32Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint32Request.ProtoReflect.Descriptor instead.
func (*IncrementUint32Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{63}
}

func (x *IncrementUint32Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementUint32Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementUint32Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementUint32Request) GetIncrementBy() uint32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementUint32Request) GetCondition() *IncrementUint32Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementUint32Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementUint32Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementUint32Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The relational operator used to evaluate the current value.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The value to compare against.
	Value         uint32 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint32Condition) Reset() {
	*x = IncrementUint32Condition{}
	mi := &file_hydraide_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint32Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint32Condition) ProtoMessage() {}

func (x *IncrementUint32Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint32Condition.ProtoReflect.Descriptor instead.
func (*IncrementUint32Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{64}
}

func (x *IncrementUint32Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementUint32Condition) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementUint32Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the updated value after incrementing,
	// or the original if the condition failed.
	Value uint32 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented indicates whether the value was modified.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint32Response) Reset() {
	*x = IncrementUint32Response{}
	mi := &file_hydraide_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint32Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint32Response) ProtoMessage() {}

func (x *IncrementUint32Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint32Response.ProtoReflect.Descriptor instead.
func (*IncrementUint32Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{65}
}

func (x *IncrementUint32Response) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementUint32Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementUint32Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementUint64Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the swamp where the treasure is located.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key identifies the treasure whose value will be incremented.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the amount to add.
	//
	// 💡 Supports the full range of unsigned 64-bit integers (0 to 18 quintillion+)
	IncrementBy uint64 `protobuf:"varint,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition must be satisfied for the operation to take place.
	Condition *IncrementUint64Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint64Request) Reset() {
	*x = IncrementUint64Request{}
	mi := &file_hydraide_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint64Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint64Request) ProtoMessage() {}

func (x *IncrementUint64Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint64Request.ProtoReflect.Descriptor instead.
func (*IncrementUint64Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{66}
}

func (x *IncrementUint64Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementUint64Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementUint64Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementUint64Request) GetIncrementBy() uint64 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementUint64Request) GetCondition() *IncrementUint64Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementUint64Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementUint64Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementUint64Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Logical operator used to compare current value.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The uint64 value to compare the current treasure value against.
	Value         uint64 `protobuf:"varint,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint64Condition) Reset() {
	*x = IncrementUint64Condition{}
	mi := &file_hydraide_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint64Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint64Condition) ProtoMessage() {}

func (x *IncrementUint64Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint64Condition.ProtoReflect.Descriptor instead.
func (*IncrementUint64Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{67}
}

func (x *IncrementUint64Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementUint64Condition) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementUint64Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the resulting value after the operation (or the original).
	Value uint64 `protobuf:"varint,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented is true if the operation was applied.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementUint64Response) Reset() {
	*x = IncrementUint64Response{}
	mi := &file_hydraide_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementUint64Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementUint64Response) ProtoMessage() {}

func (x *IncrementUint64Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementUint64Response.ProtoReflect.Descriptor instead.
func (*IncrementUint64Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{68}
}

func (x *IncrementUint64Response) GetValue() uint64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementUint64Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementUint64Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type Relational struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Relational) Reset() {
	*x = Relational{}
	mi := &file_hydraide_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Relational) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Relational) ProtoMessage() {}

func (x *Relational) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Relational.ProtoReflect.Descriptor instead.
func (*Relational) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{69}
}

type IncrementFloat32Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName identifies the swamp where the treasure is stored.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key points to the specific treasure we want to modify.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the amount to add (can be negative).
	//
	// 💡 Supports 32-bit floating point numbers.
	IncrementBy float32 `protobuf:"fixed32,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition must be met for the change to happen.
	Condition *IncrementFloat32Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat32Request) Reset() {
	*x = IncrementFloat32Request{}
	mi := &file_hydraide_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat32Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat32Request) ProtoMessage() {}

func (x *IncrementFloat32Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat32Request.ProtoReflect.Descriptor instead.
func (*IncrementFloat32Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{70}
}

func (x *IncrementFloat32Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementFloat32Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementFloat32Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementFloat32Request) GetIncrementBy() float32 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementFloat32Request) GetCondition() *IncrementFloat32Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementFloat32Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementFloat32Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementFloat32Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Logical check to evaluate before applying the increment.
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// The float value to compare the current treasure against.
	Value         float32 `protobuf:"fixed32,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat32Condition) Reset() {
	*x = IncrementFloat32Condition{}
	mi := &file_hydraide_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat32Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat32Condition) ProtoMessage() {}

func (x *IncrementFloat32Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat32Condition.ProtoReflect.Descriptor instead.
func (*IncrementFloat32Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{71}
}

func (x *IncrementFloat32Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementFloat32Condition) GetValue() float32 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementFloat32Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the result after the (conditional) increment.
	Value float32 `protobuf:"fixed32,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented is true if the change was applied.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat32Response) Reset() {
	*x = IncrementFloat32Response{}
	mi := &file_hydraide_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat32Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat32Response) ProtoMessage() {}

func (x *IncrementFloat32Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat32Response.ProtoReflect.Descriptor instead.
func (*IncrementFloat32Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{72}
}

func (x *IncrementFloat32Response) GetValue() float32 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementFloat32Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementFloat32Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

type IncrementFloat64Request struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the target swamp where the treasure lives.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key identifies the treasure to be incremented.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// IncrementBy is the floating-point value to add.
	//
	// ✅ Can be positive or negative.
	// ✅ Uses 64-bit floating-point precision.
	IncrementBy float64 `protobuf:"fixed64,4,opt,name=IncrementBy,proto3" json:"IncrementBy,omitempty"`
	// Condition that must be true for the increment to apply.
	Condition *IncrementFloat64Condition `protobuf:"bytes,5,opt,name=Condition,proto3" json:"Condition,omitempty"`
	// SetIfNotExist is optional metadata to set if the key does not exist yet.
	SetIfNotExist *IncrementRequestMetadata `protobuf:"bytes,6,opt,name=SetIfNotExist,proto3,oneof" json:"SetIfNotExist,omitempty"` // Optional metadata to set if the key does not exist yet.
	// SetIfNotExist is optional metadata to set if the key already exists.
	SetIfExist    *IncrementRequestMetadata `protobuf:"bytes,7,opt,name=SetIfExist,proto3,oneof" json:"SetIfExist,omitempty"` // Optional metadata to set if the key already exists.
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat64Request) Reset() {
	*x = IncrementFloat64Request{}
	mi := &file_hydraide_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat64Request) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat64Request) ProtoMessage() {}

func (x *IncrementFloat64Request) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat64Request.ProtoReflect.Descriptor instead.
func (*IncrementFloat64Request) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{73}
}

func (x *IncrementFloat64Request) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IncrementFloat64Request) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IncrementFloat64Request) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *IncrementFloat64Request) GetIncrementBy() float64 {
	if x != nil {
		return x.IncrementBy
	}
	return 0
}

func (x *IncrementFloat64Request) GetCondition() *IncrementFloat64Condition {
	if x != nil {
		return x.Condition
	}
	return nil
}

func (x *IncrementFloat64Request) GetSetIfNotExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfNotExist
	}
	return nil
}

func (x *IncrementFloat64Request) GetSetIfExist() *IncrementRequestMetadata {
	if x != nil {
		return x.SetIfExist
	}
	return nil
}

type IncrementFloat64Condition struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Comparison operator (e.g. GREATER_THAN, EQUAL, etc.)
	RelationalOperator Relational_Operator `protobuf:"varint,1,opt,name=RelationalOperator,proto3,enum=hydraidepbgo.Relational_Operator" json:"RelationalOperator,omitempty"`
	// Reference value to evaluate the current treasure against.
	Value         float64 `protobuf:"fixed64,2,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat64Condition) Reset() {
	*x = IncrementFloat64Condition{}
	mi := &file_hydraide_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat64Condition) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat64Condition) ProtoMessage() {}

func (x *IncrementFloat64Condition) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat64Condition.ProtoReflect.Descriptor instead.
func (*IncrementFloat64Condition) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{74}
}

func (x *IncrementFloat64Condition) GetRelationalOperator() Relational_Operator {
	if x != nil {
		return x.RelationalOperator
	}
	return Relational_EQUAL
}

func (x *IncrementFloat64Condition) GetValue() float64 {
	if x != nil {
		return x.Value
	}
	return 0
}

type IncrementFloat64Response struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Value is the new (or unchanged) value after the request.
	Value float64 `protobuf:"fixed64,1,opt,name=Value,proto3" json:"Value,omitempty"`
	// IsIncremented tells if the change actually occurred.
	IsIncremented bool `protobuf:"varint,2,opt,name=IsIncremented,proto3" json:"IsIncremented,omitempty"`
	// Metadata of the treasure
	Metadata      *IncrementResponseMetadata `protobuf:"bytes,3,opt,name=Metadata,proto3" json:"Metadata,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IncrementFloat64Response) Reset() {
	*x = IncrementFloat64Response{}
	mi := &file_hydraide_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IncrementFloat64Response) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IncrementFloat64Response) ProtoMessage() {}

func (x *IncrementFloat64Response) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IncrementFloat64Response.ProtoReflect.Descriptor instead.
func (*IncrementFloat64Response) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{75}
}

func (x *IncrementFloat64Response) GetValue() float64 {
	if x != nil {
		return x.Value
	}
	return 0
}

func (x *IncrementFloat64Response) GetIsIncremented() bool {
	if x != nil {
		return x.IsIncremented
	}
	return false
}

func (x *IncrementFloat64Response) GetMetadata() *IncrementResponseMetadata {
	if x != nil {
		return x.Metadata
	}
	return nil
}

// KeySlicePair represents a mapping between a key and a list of uint32 values.
// Used for slice-related operations like push and delete.
type KeySlicePair struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Key identifies the treasure containing the uint32 slice.
	Key string `protobuf:"bytes,1,opt,name=Key,proto3" json:"Key,omitempty"`
	// Values are the uint32 values to add or remove.
	Values        []uint32 `protobuf:"varint,2,rep,packed,name=Values,proto3" json:"Values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *KeySlicePair) Reset() {
	*x = KeySlicePair{}
	mi := &file_hydraide_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *KeySlicePair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*KeySlicePair) ProtoMessage() {}

func (x *KeySlicePair) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use KeySlicePair.ProtoReflect.Descriptor instead.
func (*KeySlicePair) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{76}
}

func (x *KeySlicePair) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeySlicePair) GetValues() []uint32 {
	if x != nil {
		return x.Values
	}
	return nil
}

// AddToUint32SlicePushRequest adds one or more uint32 values to one or more keys.
type AddToUint32SlicePushRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp containing the target slices.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// KeySlicePairs contains one or more key → value(s) mappings to push into the slices.
	KeySlicePairs []*KeySlicePair `protobuf:"bytes,3,rep,name=KeySlicePairs,proto3" json:"KeySlicePairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddToUint32SlicePushRequest) Reset() {
	*x = AddToUint32SlicePushRequest{}
	mi := &file_hydraide_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddToUint32SlicePushRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddToUint32SlicePushRequest) ProtoMessage() {}

func (x *AddToUint32SlicePushRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddToUint32SlicePushRequest.ProtoReflect.Descriptor instead.
func (*AddToUint32SlicePushRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{77}
}

func (x *AddToUint32SlicePushRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *AddToUint32SlicePushRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *AddToUint32SlicePushRequest) GetKeySlicePairs() []*KeySlicePair {
	if x != nil {
		return x.KeySlicePairs
	}
	return nil
}

// AddToUint32SlicePushResponse is returned after a successful push operation.
// This message is intentionally empty.
type AddToUint32SlicePushResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddToUint32SlicePushResponse) Reset() {
	*x = AddToUint32SlicePushResponse{}
	mi := &file_hydraide_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddToUint32SlicePushResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddToUint32SlicePushResponse) ProtoMessage() {}

func (x *AddToUint32SlicePushResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddToUint32SlicePushResponse.ProtoReflect.Descriptor instead.
func (*AddToUint32SlicePushResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{78}
}

// Uint32SliceDeleteRequest removes one or more values from one or more uint32 slices.
type Uint32SliceDeleteRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the slices are located.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// KeySlicePairs contains the keys and values to remove from the corresponding slices.
	KeySlicePairs []*KeySlicePair `protobuf:"bytes,3,rep,name=KeySlicePairs,proto3" json:"KeySlicePairs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceDeleteRequest) Reset() {
	*x = Uint32SliceDeleteRequest{}
	mi := &file_hydraide_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceDeleteRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceDeleteRequest) ProtoMessage() {}

func (x *Uint32SliceDeleteRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceDeleteRequest.ProtoReflect.Descriptor instead.
func (*Uint32SliceDeleteRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{79}
}

func (x *Uint32SliceDeleteRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *Uint32SliceDeleteRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *Uint32SliceDeleteRequest) GetKeySlicePairs() []*KeySlicePair {
	if x != nil {
		return x.KeySlicePairs
	}
	return nil
}

// Uint32SliceDeleteResponse is returned after a successful delete operation.
// This message is intentionally empty.
type Uint32SliceDeleteResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceDeleteResponse) Reset() {
	*x = Uint32SliceDeleteResponse{}
	mi := &file_hydraide_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceDeleteResponse) ProtoMessage() {}

func (x *Uint32SliceDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceDeleteResponse.ProtoReflect.Descriptor instead.
func (*Uint32SliceDeleteResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{80}
}

// Uint32SliceSizeRequest queries the size (number of elements) of a specific uint32 slice.
type Uint32SliceSizeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp containing the slice.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the identifier of the treasure whose slice we want to measure.
	Key           string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceSizeRequest) Reset() {
	*x = Uint32SliceSizeRequest{}
	mi := &file_hydraide_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceSizeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceSizeRequest) ProtoMessage() {}

func (x *Uint32SliceSizeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceSizeRequest.ProtoReflect.Descriptor instead.
func (*Uint32SliceSizeRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{81}
}

func (x *Uint32SliceSizeRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *Uint32SliceSizeRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *Uint32SliceSizeRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// Uint32SliceSizeResponse returns the current number of values in the requested slice.
type Uint32SliceSizeResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Size is the total number of uint32 values in the slice.
	Size          int64 `protobuf:"varint,1,opt,name=Size,proto3" json:"Size,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceSizeResponse) Reset() {
	*x = Uint32SliceSizeResponse{}
	mi := &file_hydraide_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceSizeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceSizeResponse) ProtoMessage() {}

func (x *Uint32SliceSizeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceSizeResponse.ProtoReflect.Descriptor instead.
func (*Uint32SliceSizeResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{82}
}

func (x *Uint32SliceSizeResponse) GetSize() int64 {
	if x != nil {
		return x.Size
	}
	return 0
}

// Uint32SliceIsValueExistRequest checks if a specific uint32 value exists in a slice.
type Uint32SliceIsValueExistRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp containing the slice.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the treasure containing the slice.
	Key string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	// Value is the uint32 number we want to check for existence.
	Value         uint32 `protobuf:"varint,4,opt,name=Value,proto3" json:"Value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceIsValueExistRequest) Reset() {
	*x = Uint32SliceIsValueExistRequest{}
	mi := &file_hydraide_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceIsValueExistRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceIsValueExistRequest) ProtoMessage() {}

func (x *Uint32SliceIsValueExistRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceIsValueExistRequest.ProtoReflect.Descriptor instead.
func (*Uint32SliceIsValueExistRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{83}
}

func (x *Uint32SliceIsValueExistRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *Uint32SliceIsValueExistRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *Uint32SliceIsValueExistRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *Uint32SliceIsValueExistRequest) GetValue() uint32 {
	if x != nil {
		return x.Value
	}
	return 0
}

// Uint32SliceIsValueExistResponse returns whether the specified value is present in the slice.
type Uint32SliceIsValueExistResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IsExist is true if the value is present in the slice, false otherwise.
	IsExist       bool `protobuf:"varint,1,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Uint32SliceIsValueExistResponse) Reset() {
	*x = Uint32SliceIsValueExistResponse{}
	mi := &file_hydraide_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Uint32SliceIsValueExistResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Uint32SliceIsValueExistResponse) ProtoMessage() {}

func (x *Uint32SliceIsValueExistResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Uint32SliceIsValueExistResponse.ProtoReflect.Descriptor instead.
func (*Uint32SliceIsValueExistResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{84}
}

func (x *Uint32SliceIsValueExistResponse) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

// IsSwampExistRequest checks whether a specific swamp exists in the current sanctuary.
type IsSwampExistRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to check.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IsSwampExistRequest) Reset() {
	*x = IsSwampExistRequest{}
	mi := &file_hydraide_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IsSwampExistRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IsSwampExistRequest) ProtoMessage() {}

func (x *IsSwampExistRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IsSwampExistRequest.ProtoReflect.Descriptor instead.
func (*IsSwampExistRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{85}
}

func (x *IsSwampExistRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IsSwampExistRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

// IsSwampExistResponse returns the existence status of the swamp.
type IsSwampExistResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IsExist will be true if the swamp exists, false otherwise.
	IsExist       bool `protobuf:"varint,1,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IsSwampExistResponse) Reset() {
	*x = IsSwampExistResponse{}
	mi := &file_hydraide_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IsSwampExistResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IsSwampExistResponse) ProtoMessage() {}

func (x *IsSwampExistResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IsSwampExistResponse.ProtoReflect.Descriptor instead.
func (*IsSwampExistResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{86}
}

func (x *IsSwampExistResponse) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

// IsKeyExistRequest checks whether a specific key exists within a given swamp.
type IsKeyExistRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp where the key is expected.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Key is the identifier of the treasure to check for existence.
	Key           string `protobuf:"bytes,3,opt,name=Key,proto3" json:"Key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IsKeyExistRequest) Reset() {
	*x = IsKeyExistRequest{}
	mi := &file_hydraide_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IsKeyExistRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IsKeyExistRequest) ProtoMessage() {}

func (x *IsKeyExistRequest) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IsKeyExistRequest.ProtoReflect.Descriptor instead.
func (*IsKeyExistRequest) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{87}
}

func (x *IsKeyExistRequest) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *IsKeyExistRequest) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *IsKeyExistRequest) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

// IsKeyExistResponse returns the existence status of the given key in the swamp.
type IsKeyExistResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IsExist will be true if the key is present in the swamp, false otherwise.
	IsExist       bool `protobuf:"varint,1,opt,name=IsExist,proto3" json:"IsExist,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IsKeyExistResponse) Reset() {
	*x = IsKeyExistResponse{}
	mi := &file_hydraide_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IsKeyExistResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IsKeyExistResponse) ProtoMessage() {}

func (x *IsKeyExistResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IsKeyExistResponse.ProtoReflect.Descriptor instead.
func (*IsKeyExistResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{88}
}

func (x *IsKeyExistResponse) GetIsExist() bool {
	if x != nil {
		return x.IsExist
	}
	return false
}

type DeleteRequest_SwampKeys struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName identifies the target swamp.
	SwampName string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// Keys are the specific treasure keys to delete from the swamp.
	Keys          []string `protobuf:"bytes,3,rep,name=Keys,proto3" json:"Keys,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteRequest_SwampKeys) Reset() {
	*x = DeleteRequest_SwampKeys{}
	mi := &file_hydraide_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteRequest_SwampKeys) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteRequest_SwampKeys) ProtoMessage() {}

func (x *DeleteRequest_SwampKeys) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteRequest_SwampKeys.ProtoReflect.Descriptor instead.
func (*DeleteRequest_SwampKeys) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{38, 0}
}

func (x *DeleteRequest_SwampKeys) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *DeleteRequest_SwampKeys) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *DeleteRequest_SwampKeys) GetKeys() []string {
	if x != nil {
		return x.Keys
	}
	return nil
}

type DeleteResponse_SwampDeleteResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SwampName is the swamp where deletion was attempted.
	SwampName string `protobuf:"bytes,1,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	// ErrorCode indicates if the swamp existed or failed to be accessed.
	ErrorCode *DeleteResponse_SwampDeleteResponse_ErrorCodeEnum `protobuf:"varint,2,opt,name=ErrorCode,proto3,enum=hydraidepbgo.DeleteResponse_SwampDeleteResponse_ErrorCodeEnum,oneof" json:"ErrorCode,omitempty"`
	// KeyStatuses contains the result of each key deletion:
	// NEW (not found before), DELETED, NOTHING_CHANGED, etc.
	KeyStatuses   []*KeyStatusPair `protobuf:"bytes,3,rep,name=KeyStatuses,proto3" json:"KeyStatuses,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResponse_SwampDeleteResponse) Reset() {
	*x = DeleteResponse_SwampDeleteResponse{}
	mi := &file_hydraide_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResponse_SwampDeleteResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResponse_SwampDeleteResponse) ProtoMessage() {}

func (x *DeleteResponse_SwampDeleteResponse) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResponse_SwampDeleteResponse.ProtoReflect.Descriptor instead.
func (*DeleteResponse_SwampDeleteResponse) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{39, 0}
}

func (x *DeleteResponse_SwampDeleteResponse) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

func (x *DeleteResponse_SwampDeleteResponse) GetErrorCode() DeleteResponse_SwampDeleteResponse_ErrorCodeEnum {
	if x != nil && x.ErrorCode != nil {
		return *x.ErrorCode
	}
	return DeleteResponse_SwampDeleteResponse_SwampDoesNotExist
}

func (x *DeleteResponse_SwampDeleteResponse) GetKeyStatuses() []*KeyStatusPair {
	if x != nil {
		return x.KeyStatuses
	}
	return nil
}

type CountRequest_SwampIdentifier struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// IslandID is the deterministic storage zone (or "island") where this Swamp lives.
	IslandID uint64 `protobuf:"varint,1,opt,name=IslandID,proto3" json:"IslandID,omitempty"`
	// SwampName is the name of the swamp to count.
	SwampName     string `protobuf:"bytes,2,opt,name=SwampName,proto3" json:"SwampName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CountRequest_SwampIdentifier) Reset() {
	*x = CountRequest_SwampIdentifier{}
	mi := &file_hydraide_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CountRequest_SwampIdentifier) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CountRequest_SwampIdentifier) ProtoMessage() {}

func (x *CountRequest_SwampIdentifier) ProtoReflect() protoreflect.Message {
	mi := &file_hydraide_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CountRequest_SwampIdentifier.ProtoReflect.Descriptor instead.
func (*CountRequest_SwampIdentifier) Descriptor() ([]byte, []int) {
	return file_hydraide_proto_rawDescGZIP(), []int{40, 0}
}

func (x *CountRequest_SwampIdentifier) GetIslandID() uint64 {
	if x != nil {
		return x.IslandID
	}
	return 0
}

func (x *CountRequest_SwampIdentifier) GetSwampName() string {
	if x != nil {
		return x.SwampName
	}
	return ""
}

var File_hydraide_proto protoreflect.FileDescriptor

const file_hydraide_proto_rawDesc = "" +
	"\n" +
	"\x0ehydraide.proto\x12\fhydraidepbgo\x1a\x1fgoogle/protobuf/timestamp.proto\"&\n" +
	"\x10HeartbeatRequest\x12\x12\n" +
	"\x04Ping\x18\x01 \x01(\tR\x04Ping\"'\n" +
	"\x11HeartbeatResponse\x12\x12\n" +
	"\x04Pong\x18\x01 \x01(\tR\x04Pong\"1\n" +
	"\vLockRequest\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x12\x10\n" +
	"\x03TTL\x18\x02 \x01(\x03R\x03TTL\"&\n" +
	"\fLockResponse\x12\x16\n" +
	"\x06LockID\x18\x01 \x01(\tR\x06LockID\"9\n" +
	"\rUnlockRequest\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x12\x16\n" +
	"\x06LockID\x18\x02 \x01(\tR\x06LockID\"\x10\n" +
	"\x0eUnlockResponse\"J\n" +
	"\x0eDestroyRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"\x11\n" +
	"\x0fDestroyResponse\"R\n" +
	"\x16SubscribeToInfoRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"Y\n" +
	"\x17SubscribeToInfoResponse\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12 \n" +
	"\vAllElements\x18\x02 \x01(\x04R\vAllElements\"T\n" +
	"\x18SubscribeToEventsRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"\xd6\x02\n" +
	"\x19SubscribeToEventsResponse\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x122\n" +
	"\bTreasure\x18\x02 \x01(\v2\x16.hydraidepbgo.TreasureR\bTreasure\x128\n" +
	"\vOldTreasure\x18\x03 \x01(\v2\x16.hydraidepbgo.TreasureR\vOldTreasure\x12@\n" +
	"\x0fDeletedTreasure\x18\x04 \x01(\v2\x16.hydraidepbgo.TreasureR\x0fDeletedTreasure\x128\n" +
	"\tEventTime\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\tEventTime\x121\n" +
	"\x06Status\x18\x06 \x01(\x0e2\x19.hydraidepbgo.Status.CodeR\x06Status\"=\n" +
	"\tSwampKeys\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12\x12\n" +
	"\x04Keys\x18\x02 \x03(\tR\x04Keys\"\x80\x02\n" +
	"\x14RegisterSwampRequest\x12\"\n" +
	"\fSwampPattern\x18\x01 \x01(\tR\fSwampPattern\x12&\n" +
	"\x0eCloseAfterIdle\x18\x02 \x01(\x03R\x0eCloseAfterIdle\x12(\n" +
	"\x0fIsInMemorySwamp\x18\x03 \x01(\bR\x0fIsInMemorySwamp\x12)\n" +
	"\rWriteInterval\x18\x04 \x01(\x03H\x00R\rWriteInterval\x88\x01\x01\x12%\n" +
	"\vMaxFileSize\x18\x05 \x01(\x03H\x01R\vMaxFileSize\x88\x01\x01B\x10\n" +
	"\x0e_WriteIntervalB\x0e\n" +
	"\f_MaxFileSize\"\x17\n" +
	"\x15RegisterSwampResponse\"<\n" +
	"\x16DeRegisterSwampRequest\x12\"\n" +
	"\fSwampPattern\x18\x01 \x01(\tR\fSwampPattern\"\x19\n" +
	"\x17DeRegisterSwampResponse\"@\n" +
	"\n" +
	"SetRequest\x122\n" +
	"\x06Swamps\x18\x01 \x03(\v2\x1a.hydraidepbgo.SwampRequestR\x06Swamps\"\xcc\x01\n" +
	"\fSwampRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x128\n" +
	"\tKeyValues\x18\x03 \x03(\v2\x1a.hydraidepbgo.KeyValuePairR\tKeyValues\x12*\n" +
	"\x10CreateIfNotExist\x18\x04 \x01(\bR\x10CreateIfNotExist\x12\x1c\n" +
	"\tOverwrite\x18\x05 \x01(\bR\tOverwrite\"\xba\b\n" +
	"\fKeyValuePair\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x12\x1d\n" +
	"\aInt8Val\x18\x02 \x01(\x05H\x00R\aInt8Val\x88\x01\x01\x12\x1f\n" +
	"\bInt16Val\x18\x03 \x01(\x05H\x01R\bInt16Val\x88\x01\x01\x12\x1f\n" +
	"\bInt32Val\x18\x04 \x01(\x05H\x02R\bInt32Val\x88\x01\x01\x12\x1f\n" +
	"\bInt64Val\x18\x05 \x01(\x03H\x03R\bInt64Val\x88\x01\x01\x12\x1f\n" +
	"\bUint8Val\x18\x06 \x01(\rH\x04R\bUint8Val\x88\x01\x01\x12!\n" +
	"\tUint16Val\x18\a \x01(\rH\x05R\tUint16Val\x88\x01\x01\x12!\n" +
	"\tUint32Val\x18\b \x01(\rH\x06R\tUint32Val\x88\x01\x01\x12!\n" +
	"\tUint64Val\x18\t \x01(\x04H\aR\tUint64Val\x88\x01\x01\x12#\n" +
	"\n" +
	"Float32Val\x18\n" +
	" \x01(\x02H\bR\n" +
	"Float32Val\x88\x01\x01\x12#\n" +
	"\n" +
	"Float64Val\x18\v \x01(\x01H\tR\n" +
	"Float64Val\x88\x01\x01\x12!\n" +
	"\tStringVal\x18\f \x01(\tH\n" +
	"R\tStringVal\x88\x01\x01\x129\n" +
	"\aBoolVal\x18\r \x01(\x0e2\x1a.hydraidepbgo.Boolean.TypeH\vR\aBoolVal\x88\x01\x01\x12\x1f\n" +
	"\bBytesVal\x18\x0e \x01(\fH\fR\bBytesVal\x88\x01\x01\x12 \n" +
	"\vUint32Slice\x18\x0f \x03(\rR\vUint32Slice\x12\x1d\n" +
	"\aVoidVal\x18\x10 \x01(\bH\rR\aVoidVal\x88\x01\x01\x12=\n" +
	"\tCreatedAt\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampH\x0eR\tCreatedAt\x88\x01\x01\x12!\n" +
	"\tCreatedBy\x18\x12 \x01(\tH\x0fR\tCreatedBy\x88\x01\x01\x12=\n" +
	"\tUpdatedAt\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampH\x10R\tUpdatedAt\x88\x01\x01\x12!\n" +
	"\tUpdatedBy\x18\x14 \x01(\tH\x11R\tUpdatedBy\x88\x01\x01\x12=\n" +
	"\tExpiredAt\x18\x15 \x01(\v2\x1a.google.protobuf.TimestampH\x12R\tExpiredAt\x88\x01\x01B\n" +
	"\n" +
	"\b_Int8ValB\v\n" +
	"\t_Int16ValB\v\n" +
	"\t_Int32ValB\v\n" +
	"\t_Int64ValB\v\n" +
	"\t_Uint8ValB\f\n" +
	"\n" +
	"_Uint16ValB\f\n" +
	"\n" +
	"_Uint32ValB\f\n" +
	"\n" +
	"_Uint64ValB\r\n" +
	"\v_Float32ValB\r\n" +
	"\v_Float64ValB\f\n" +
	"\n" +
	"_StringValB\n" +
	"\n" +
	"\b_BoolValB\v\n" +
	"\t_BytesValB\n" +
	"\n" +
	"\b_VoidValB\f\n" +
	"\n" +
	"_CreatedAtB\f\n" +
	"\n" +
	"_CreatedByB\f\n" +
	"\n" +
	"_UpdatedAtB\f\n" +
	"\n" +
	"_UpdatedByB\f\n" +
	"\n" +
	"_ExpiredAt\"B\n" +
	"\vSetResponse\x123\n" +
	"\x06Swamps\x18\x01 \x03(\v2\x1b.hydraidepbgo.SwampResponseR\x06Swamps\"\x8a\x02\n" +
	"\rSwampResponse\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12E\n" +
	"\x0fKeysAndStatuses\x18\x02 \x03(\v2\x1b.hydraidepbgo.KeyStatusPairR\x0fKeysAndStatuses\x12J\n" +
	"\tErrorCode\x18\x03 \x01(\x0e2'.hydraidepbgo.SwampResponse.ErrCodeEnumH\x00R\tErrorCode\x88\x01\x01\":\n" +
	"\vErrCodeEnum\x12\x14\n" +
	"\x10CanNotBeExecuted\x10\x00\x12\x15\n" +
	"\x11SwampDoesNotExist\x10\x01B\f\n" +
	"\n" +
	"_ErrorCode\"T\n" +
	"\rKeyStatusPair\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x121\n" +
	"\x06Status\x18\x02 \x01(\x0e2\x19.hydraidepbgo.Status.CodeR\x06Status\"W\n" +
	"\x06Status\"M\n" +
	"\x04Code\x12\r\n" +
	"\tNOT_FOUND\x10\x00\x12\a\n" +
	"\x03NEW\x10\x01\x12\v\n" +
	"\aUPDATED\x10\x02\x12\v\n" +
	"\aDELETED\x10\x03\x12\x13\n" +
	"\x0fNOTHING_CHANGED\x10\x04\"<\n" +
	"\n" +
	"GetRequest\x12.\n" +
	"\x06Swamps\x18\x01 \x03(\v2\x16.hydraidepbgo.GetSwampR\x06Swamps\"X\n" +
	"\bGetSwamp\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x12\n" +
	"\x04Keys\x18\x03 \x03(\tR\x04Keys\"E\n" +
	"\vGetResponse\x126\n" +
	"\x06Swamps\x18\x01 \x03(\v2\x1e.hydraidepbgo.GetSwampResponseR\x06Swamps\"\x80\x01\n" +
	"\x10GetSwampResponse\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12\x18\n" +
	"\aIsExist\x18\x02 \x01(\bR\aIsExist\x124\n" +
	"\tTreasures\x18\x03 \x03(\v2\x16.hydraidepbgo.TreasureR\tTreasures\"I\n" +
	"\rGetAllRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"F\n" +
	"\x0eGetAllResponse\x124\n" +
	"\tTreasures\x18\x01 \x03(\v2\x16.hydraidepbgo.TreasureR\tTreasures\"r\n" +
	"\x1cShiftExpiredTreasuresRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x18\n" +
	"\aHowMany\x18\x03 \x01(\x05R\aHowMany\"U\n" +
	"\x1dShiftExpiredTreasuresResponse\x124\n" +
	"\tTreasures\x18\x01 \x03(\v2\x16.hydraidepbgo.TreasureR\tTreasures\"\xa5\b\n" +
	"\bTreasure\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x12\x18\n" +
	"\aIsExist\x18\x02 \x01(\bR\aIsExist\x12\x1d\n" +
	"\aInt8Val\x18\x03 \x01(\x05H\x00R\aInt8Val\x88\x01\x01\x12\x1f\n" +
	"\bInt16Val\x18\x04 \x01(\x05H\x01R\bInt16Val\x88\x01\x01\x12\x1f\n" +
	"\bInt32Val\x18\x05 \x01(\x05H\x02R\bInt32Val\x88\x01\x01\x12\x1f\n" +
	"\bInt64Val\x18\x06 \x01(\x03H\x03R\bInt64Val\x88\x01\x01\x12\x1f\n" +
	"\bUint8Val\x18\a \x01(\rH\x04R\bUint8Val\x88\x01\x01\x12!\n" +
	"\tUint16Val\x18\b \x01(\rH\x05R\tUint16Val\x88\x01\x01\x12!\n" +
	"\tUint32Val\x18\t \x01(\rH\x06R\tUint32Val\x88\x01\x01\x12!\n" +
	"\tUint64Val\x18\n" +
	" \x01(\x04H\aR\tUint64Val\x88\x01\x01\x12#\n" +
	"\n" +
	"Float32Val\x18\v \x01(\x02H\bR\n" +
	"Float32Val\x88\x01\x01\x12#\n" +
	"\n" +
	"Float64Val\x18\f \x01(\x01H\tR\n" +
	"Float64Val\x88\x01\x01\x12!\n" +
	"\tStringVal\x18\r \x01(\tH\n" +
	"R\tStringVal\x88\x01\x01\x129\n" +
	"\aBoolVal\x18\x0e \x01(\x0e2\x1a.hydraidepbgo.Boolean.TypeH\vR\aBoolVal\x88\x01\x01\x12\x1f\n" +
	"\bBytesVal\x18\x0f \x01(\fH\fR\bBytesVal\x88\x01\x01\x12 \n" +
	"\vUint32Slice\x18\x10 \x03(\rR\vUint32Slice\x12=\n" +
	"\tCreatedAt\x18\x11 \x01(\v2\x1a.google.protobuf.TimestampH\rR\tCreatedAt\x88\x01\x01\x12!\n" +
	"\tCreatedBy\x18\x12 \x01(\tH\x0eR\tCreatedBy\x88\x01\x01\x12=\n" +
	"\tUpdatedAt\x18\x13 \x01(\v2\x1a.google.protobuf.TimestampH\x0fR\tUpdatedAt\x88\x01\x01\x12!\n" +
	"\tUpdatedBy\x18\x14 \x01(\tH\x10R\tUpdatedBy\x88\x01\x01\x12=\n" +
	"\tExpiredAt\x18\x15 \x01(\v2\x1a.google.protobuf.TimestampH\x11R\tExpiredAt\x88\x01\x01B\n" +
	"\n" +
	"\b_Int8ValB\v\n" +
	"\t_Int16ValB\v\n" +
	"\t_Int32ValB\v\n" +
	"\t_Int64ValB\v\n" +
	"\t_Uint8ValB\f\n" +
	"\n" +
	"_Uint16ValB\f\n" +
	"\n" +
	"_Uint32ValB\f\n" +
	"\n" +
	"_Uint64ValB\r\n" +
	"\v_Float32ValB\r\n" +
	"\v_Float64ValB\f\n" +
	"\n" +
	"_StringValB\n" +
	"\n" +
	"\b_BoolValB\v\n" +
	"\t_BytesValB\f\n" +
	"\n" +
	"_CreatedAtB\f\n" +
	"\n" +
	"_CreatedByB\f\n" +
	"\n" +
	"_UpdatedAtB\f\n" +
	"\n" +
	"_UpdatedByB\f\n" +
	"\n" +
	"_ExpiredAt\"&\n" +
	"\aBoolean\"\x1b\n" +
	"\x04Type\x12\b\n" +
	"\x04TRUE\x10\x00\x12\t\n" +
	"\x05FALSE\x10\x01\"\xef\x01\n" +
	"\x11GetByIndexRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12:\n" +
	"\tIndexType\x18\x03 \x01(\x0e2\x1c.hydraidepbgo.IndexType.TypeR\tIndexType\x12:\n" +
	"\tOrderType\x18\x04 \x01(\x0e2\x1c.hydraidepbgo.OrderType.TypeR\tOrderType\x12\x12\n" +
	"\x04From\x18\x05 \x01(\x05R\x04From\x12\x14\n" +
	"\x05Limit\x18\x06 \x01(\x05R\x05Limit\"\x98\x02\n" +
	"\tIndexType\"\x8a\x02\n" +
	"\x04Type\x12\a\n" +
	"\x03KEY\x10\x00\x12\x13\n" +
	"\x0fEXPIRATION_TIME\x10\x01\x12\x11\n" +
	"\rCREATION_TIME\x10\x02\x12\x0f\n" +
	"\vUPDATE_TIME\x10\x03\x12\x0e\n" +
	"\n" +
	"VALUE_INT8\x10\x04\x12\x0f\n" +
	"\vVALUE_INT16\x10\x05\x12\x0f\n" +
	"\vVALUE_INT32\x10\x06\x12\x0f\n" +
	"\vVALUE_INT64\x10\a\x12\x0f\n" +
	"\vVALUE_UINT8\x10\b\x12\x10\n" +
	"\fVALUE_UINT16\x10\t\x12\x10\n" +
	"\fVALUE_UINT32\x10\n" +
	"\x12\x10\n" +
	"\fVALUE_UINT64\x10\v\x12\x11\n" +
	"\rVALUE_FLOAT32\x10\f\x12\x11\n" +
	"\rVALUE_FLOAT64\x10\r\x12\x10\n" +
	"\fVALUE_STRING\x10\x0e\"&\n" +
	"\tOrderType\"\x19\n" +
	"\x04Type\x12\a\n" +
	"\x03ASC\x10\x00\x12\b\n" +
	"\x04DESC\x10\x01\"J\n" +
	"\x12GetByIndexResponse\x124\n" +
	"\tTreasures\x18\x01 \x03(\v2\x16.hydraidepbgo.TreasureR\tTreasures\"\xa9\x01\n" +
	"\rDeleteRequest\x12=\n" +
	"\x06Swamps\x18\x01 \x03(\v2%.hydraidepbgo.DeleteRequest.SwampKeysR\x06Swamps\x1aY\n" +
	"\tSwampKeys\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x12\n" +
	"\x04Keys\x18\x03 \x03(\tR\x04Keys\"\xee\x02\n" +
	"\x0eDeleteResponse\x12N\n" +
	"\tResponses\x18\x01 \x03(\v20.hydraidepbgo.DeleteResponse.SwampDeleteResponseR\tResponses\x1a\x8b\x02\n" +
	"\x13SwampDeleteResponse\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12a\n" +
	"\tErrorCode\x18\x02 \x01(\x0e2>.hydraidepbgo.DeleteResponse.SwampDeleteResponse.ErrorCodeEnumH\x00R\tErrorCode\x88\x01\x01\x12=\n" +
	"\vKeyStatuses\x18\x03 \x03(\v2\x1b.hydraidepbgo.KeyStatusPairR\vKeyStatuses\"&\n" +
	"\rErrorCodeEnum\x12\x15\n" +
	"\x11SwampDoesNotExist\x10\x00B\f\n" +
	"\n" +
	"_ErrorCode\"\x9f\x01\n" +
	"\fCountRequest\x12B\n" +
	"\x06Swamps\x18\x01 \x03(\v2*.hydraidepbgo.CountRequest.SwampIdentifierR\x06Swamps\x1aK\n" +
	"\x0fSwampIdentifier\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"A\n" +
	"\rCountResponse\x120\n" +
	"\x06Swamps\x18\x01 \x03(\v2\x18.hydraidepbgo.CountSwampR\x06Swamps\"Z\n" +
	"\n" +
	"CountSwamp\x12\x1c\n" +
	"\tSwampName\x18\x01 \x01(\tR\tSwampName\x12\x18\n" +
	"\aIsExist\x18\x02 \x01(\bR\aIsExist\x12\x14\n" +
	"\x05Count\x18\x03 \x01(\x05R\x05Count\"\xab\x02\n" +
	"\x18IncrementRequestMetadata\x12!\n" +
	"\tCreatedAt\x18\x01 \x01(\bH\x00R\tCreatedAt\x88\x01\x01\x12!\n" +
	"\tCreatedBy\x18\x02 \x01(\tH\x01R\tCreatedBy\x88\x01\x01\x12!\n" +
	"\tUpdatedAt\x18\x03 \x01(\bH\x02R\tUpdatedAt\x88\x01\x01\x12!\n" +
	"\tUpdatedBy\x18\x04 \x01(\tH\x03R\tUpdatedBy\x88\x01\x01\x12=\n" +
	"\tExpiredAt\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x04R\tExpiredAt\x88\x01\x01B\f\n" +
	"\n" +
	"_CreatedAtB\f\n" +
	"\n" +
	"_CreatedByB\f\n" +
	"\n" +
	"_UpdatedAtB\f\n" +
	"\n" +
	"_UpdatedByB\f\n" +
	"\n" +
	"_ExpiredAt\"\xe4\x02\n" +
	"\x19IncrementResponseMetadata\x12=\n" +
	"\tCreatedAt\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\tCreatedAt\x88\x01\x01\x12!\n" +
	"\tCreatedBy\x18\x02 \x01(\tH\x01R\tCreatedBy\x88\x01\x01\x12=\n" +
	"\tUpdatedAt\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampH\x02R\tUpdatedAt\x88\x01\x01\x12!\n" +
	"\tUpdatedBy\x18\x04 \x01(\tH\x03R\tUpdatedBy\x88\x01\x01\x12=\n" +
	"\tExpiredAt\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampH\x04R\tExpiredAt\x88\x01\x01B\f\n" +
	"\n" +
	"_CreatedAtB\f\n" +
	"\n" +
	"_CreatedByB\f\n" +
	"\n" +
	"_UpdatedAtB\f\n" +
	"\n" +
	"_UpdatedByB\f\n" +
	"\n" +
	"_ExpiredAt\"\x89\x03\n" +
	"\x14IncrementInt8Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x05R\vIncrementBy\x12B\n" +
	"\tCondition\x18\x05 \x01(\v2$.hydraidepbgo.IncrementInt8ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x81\x01\n" +
	"\x16IncrementInt8Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x05R\x05Value\"\x98\x01\n" +
	"\x15IncrementInt8Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x05R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8b\x03\n" +
	"\x15IncrementInt16Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x05R\vIncrementBy\x12C\n" +
	"\tCondition\x18\x05 \x01(\v2%.hydraidepbgo.IncrementInt16ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x82\x01\n" +
	"\x17IncrementInt16Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x05R\x05Value\"\x99\x01\n" +
	"\x16IncrementInt16Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x05R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8b\x03\n" +
	"\x15IncrementInt32Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x05R\vIncrementBy\x12C\n" +
	"\tCondition\x18\x05 \x01(\v2%.hydraidepbgo.IncrementInt32ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x82\x01\n" +
	"\x17IncrementInt32Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x05R\x05Value\"\x99\x01\n" +
	"\x16IncrementInt32Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x05R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8b\x03\n" +
	"\x15IncrementInt64Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x03R\vIncrementBy\x12C\n" +
	"\tCondition\x18\x05 \x01(\v2%.hydraidepbgo.IncrementInt64ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x82\x01\n" +
	"\x17IncrementInt64Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x03R\x05Value\"\x99\x01\n" +
	"\x16IncrementInt64Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x03R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8b\x03\n" +
	"\x15IncrementUint8Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\rR\vIncrementBy\x12C\n" +
	"\tCondition\x18\x05 \x01(\v2%.hydraidepbgo.IncrementUint8ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x82\x01\n" +
	"\x17IncrementUint8Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\rR\x05Value\"\x99\x01\n" +
	"\x16IncrementUint8Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\rR\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8d\x03\n" +
	"\x16IncrementUint16Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\rR\vIncrementBy\x12D\n" +
	"\tCondition\x18\x05 \x01(\v2&.hydraidepbgo.IncrementUint16ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x83\x01\n" +
	"\x18IncrementUint16Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\rR\x05Value\"\x9a\x01\n" +
	"\x17IncrementUint16Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\rR\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8d\x03\n" +
	"\x16IncrementUint32Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\rR\vIncrementBy\x12D\n" +
	"\tCondition\x18\x05 \x01(\v2&.hydraidepbgo.IncrementUint32ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x83\x01\n" +
	"\x18IncrementUint32Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\rR\x05Value\"\x9a\x01\n" +
	"\x17IncrementUint32Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\rR\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8d\x03\n" +
	"\x16IncrementUint64Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x04R\vIncrementBy\x12D\n" +
	"\tCondition\x18\x05 \x01(\v2&.hydraidepbgo.IncrementUint64ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x83\x01\n" +
	"\x18IncrementUint64Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x04R\x05Value\"\x9a\x01\n" +
	"\x17IncrementUint64Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x04R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x86\x01\n" +
	"\n" +
	"Relational\"x\n" +
	"\bOperator\x12\t\n" +
	"\x05EQUAL\x10\x00\x12\x10\n" +
	"\fGREATER_THAN\x10\x01\x12\x19\n" +
	"\x15GREATER_THAN_OR_EQUAL\x10\x02\x12\r\n" +
	"\tLESS_THAN\x10\x03\x12\x16\n" +
	"\x12LESS_THAN_OR_EQUAL\x10\x04\x12\r\n" +
	"\tNOT_EQUAL\x10\x05\"\x8f\x03\n" +
	"\x17IncrementFloat32Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x02R\vIncrementBy\x12E\n" +
	"\tCondition\x18\x05 \x01(\v2'.hydraidepbgo.IncrementFloat32ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x84\x01\n" +
	"\x19IncrementFloat32Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x02R\x05Value\"\x9b\x01\n" +
	"\x18IncrementFloat32Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x02R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"\x8f\x03\n" +
	"\x17IncrementFloat64Request\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12 \n" +
	"\vIncrementBy\x18\x04 \x01(\x01R\vIncrementBy\x12E\n" +
	"\tCondition\x18\x05 \x01(\v2'.hydraidepbgo.IncrementFloat64ConditionR\tCondition\x12Q\n" +
	"\rSetIfNotExist\x18\x06 \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x00R\rSetIfNotExist\x88\x01\x01\x12K\n" +
	"\n" +
	"SetIfExist\x18\a \x01(\v2&.hydraidepbgo.IncrementRequestMetadataH\x01R\n" +
	"SetIfExist\x88\x01\x01B\x10\n" +
	"\x0e_SetIfNotExistB\r\n" +
	"\v_SetIfExist\"\x84\x01\n" +
	"\x19IncrementFloat64Condition\x12Q\n" +
	"\x12RelationalOperator\x18\x01 \x01(\x0e2!.hydraidepbgo.Relational.OperatorR\x12RelationalOperator\x12\x14\n" +
	"\x05Value\x18\x02 \x01(\x01R\x05Value\"\x9b\x01\n" +
	"\x18IncrementFloat64Response\x12\x14\n" +
	"\x05Value\x18\x01 \x01(\x01R\x05Value\x12$\n" +
	"\rIsIncremented\x18\x02 \x01(\bR\rIsIncremented\x12C\n" +
	"\bMetadata\x18\x03 \x01(\v2'.hydraidepbgo.IncrementResponseMetadataR\bMetadata\"8\n" +
	"\fKeySlicePair\x12\x10\n" +
	"\x03Key\x18\x01 \x01(\tR\x03Key\x12\x16\n" +
	"\x06Values\x18\x02 \x03(\rR\x06Values\"\x99\x01\n" +
	"\x1bAddToUint32SlicePushRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12@\n" +
	"\rKeySlicePairs\x18\x03 \x03(\v2\x1a.hydraidepbgo.KeySlicePairR\rKeySlicePairs\"\x1e\n" +
	"\x1cAddToUint32SlicePushResponse\"\x96\x01\n" +
	"\x18Uint32SliceDeleteRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12@\n" +
	"\rKeySlicePairs\x18\x03 \x03(\v2\x1a.hydraidepbgo.KeySlicePairR\rKeySlicePairs\"\x1b\n" +
	"\x19Uint32SliceDeleteResponse\"d\n" +
	"\x16Uint32SliceSizeRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\"-\n" +
	"\x17Uint32SliceSizeResponse\x12\x12\n" +
	"\x04Size\x18\x01 \x01(\x03R\x04Size\"\x82\x01\n" +
	"\x1eUint32SliceIsValueExistRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\x12\x14\n" +
	"\x05Value\x18\x04 \x01(\rR\x05Value\";\n" +
	"\x1fUint32SliceIsValueExistResponse\x12\x18\n" +
	"\aIsExist\x18\x01 \x01(\bR\aIsExist\"O\n" +
	"\x13IsSwampExistRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\"0\n" +
	"\x14IsSwampExistResponse\x12\x18\n" +
	"\aIsExist\x18\x01 \x01(\bR\aIsExist\"_\n" +
	"\x11IsKeyExistRequest\x12\x1a\n" +
	"\bIslandID\x18\x01 \x01(\x04R\bIslandID\x12\x1c\n" +
	"\tSwampName\x18\x02 \x01(\tR\tSwampName\x12\x10\n" +
	"\x03Key\x18\x03 \x01(\tR\x03Key\".\n" +
	"\x12IsKeyExistResponse\x12\x18\n" +
	"\aIsExist\x18\x01 \x01(\bR\aIsExist2\xf8\x15\n" +
	"\x0fHydraideService\x12N\n" +
	"\tHeartbeat\x12\x1e.hydraidepbgo.HeartbeatRequest\x1a\x1f.hydraidepbgo.HeartbeatResponse\"\x00\x12?\n" +
	"\x04Lock\x12\x19.hydraidepbgo.LockRequest\x1a\x1a.hydraidepbgo.LockResponse\"\x00\x12E\n" +
	"\x06Unlock\x12\x1b.hydraidepbgo.UnlockRequest\x1a\x1c.hydraidepbgo.UnlockResponse\"\x00\x12Z\n" +
	"\rRegisterSwamp\x12\".hydraidepbgo.RegisterSwampRequest\x1a#.hydraidepbgo.RegisterSwampResponse\"\x00\x12`\n" +
	"\x0fDeRegisterSwamp\x12$.hydraidepbgo.DeRegisterSwampRequest\x1a%.hydraidepbgo.DeRegisterSwampResponse\"\x00\x12<\n" +
	"\x03Set\x12\x18.hydraidepbgo.SetRequest\x1a\x19.hydraidepbgo.SetResponse\"\x00\x12<\n" +
	"\x03Get\x12\x18.hydraidepbgo.GetRequest\x1a\x19.hydraidepbgo.GetResponse\"\x00\x12E\n" +
	"\x06GetAll\x12\x1b.hydraidepbgo.GetAllRequest\x1a\x1c.hydraidepbgo.GetAllResponse\"\x00\x12Q\n" +
	"\n" +
	"GetByIndex\x12\x1f.hydraidepbgo.GetByIndexRequest\x1a .hydraidepbgo.GetByIndexResponse\"\x00\x12r\n" +
	"\x15ShiftExpiredTreasures\x12*.hydraidepbgo.ShiftExpiredTreasuresRequest\x1a+.hydraidepbgo.ShiftExpiredTreasuresResponse\"\x00\x12H\n" +
	"\aDestroy\x12\x1c.hydraidepbgo.DestroyRequest\x1a\x1d.hydraidepbgo.DestroyResponse\"\x00\x12E\n" +
	"\x06Delete\x12\x1b.hydraidepbgo.DeleteRequest\x1a\x1c.hydraidepbgo.DeleteResponse\"\x00\x12B\n" +
	"\x05Count\x12\x1a.hydraidepbgo.CountRequest\x1a\x1b.hydraidepbgo.CountResponse\"\x00\x12W\n" +
	"\fIsSwampExist\x12!.hydraidepbgo.IsSwampExistRequest\x1a\".hydraidepbgo.IsSwampExistResponse\"\x00\x12Q\n" +
	"\n" +
	"IsKeyExist\x12\x1f.hydraidepbgo.IsKeyExistRequest\x1a .hydraidepbgo.IsKeyExistResponse\"\x00\x12h\n" +
	"\x11SubscribeToEvents\x12&.hydraidepbgo.SubscribeToEventsRequest\x1a'.hydraidepbgo.SubscribeToEventsResponse\"\x000\x01\x12b\n" +
	"\x0fSubscribeToInfo\x12$.hydraidepbgo.SubscribeToInfoRequest\x1a%.hydraidepbgo.SubscribeToInfoResponse\"\x000\x01\x12j\n" +
	"\x0fUint32SlicePush\x12).hydraidepbgo.AddToUint32SlicePushRequest\x1a*.hydraidepbgo.AddToUint32SlicePushResponse\"\x00\x12f\n" +
	"\x11Uint32SliceDelete\x12&.hydraidepbgo.Uint32SliceDeleteRequest\x1a'.hydraidepbgo.Uint32SliceDeleteResponse\"\x00\x12`\n" +
	"\x0fUint32SliceSize\x12$.hydraidepbgo.Uint32SliceSizeRequest\x1a%.hydraidepbgo.Uint32SliceSizeResponse\"\x00\x12x\n" +
	"\x17Uint32SliceIsValueExist\x12,.hydraidepbgo.Uint32SliceIsValueExistRequest\x1a-.hydraidepbgo.Uint32SliceIsValueExistResponse\"\x00\x12Z\n" +
	"\rIncrementInt8\x12\".hydraidepbgo.IncrementInt8Request\x1a#.hydraidepbgo.IncrementInt8Response\"\x00\x12]\n" +
	"\x0eIncrementInt16\x12#.hydraidepbgo.IncrementInt16Request\x1a$.hydraidepbgo.IncrementInt16Response\"\x00\x12]\n" +
	"\x0eIncrementInt32\x12#.hydraidepbgo.IncrementInt32Request\x1a$.hydraidepbgo.IncrementInt32Response\"\x00\x12]\n" +
	"\x0eIncrementInt64\x12#.hydraidepbgo.IncrementInt64Request\x1a$.hydraidepbgo.IncrementInt64Response\"\x00\x12]\n" +
	"\x0eIncrementUint8\x12#.hydraidepbgo.IncrementUint8Request\x1a$.hydraidepbgo.IncrementUint8Response\"\x00\x12`\n" +
	"\x0fIncrementUint16\x12$.hydraidepbgo.IncrementUint16Request\x1a%.hydraidepbgo.IncrementUint16Response\"\x00\x12`\n" +
	"\x0fIncrementUint32\x12$.hydraidepbgo.IncrementUint32Request\x1a%.hydraidepbgo.IncrementUint32Response\"\x00\x12`\n" +
	"\x0fIncrementUint64\x12$.hydraidepbgo.IncrementUint64Request\x1a%.hydraidepbgo.IncrementUint64Response\"\x00\x12c\n" +
	"\x10IncrementFloat32\x12%.hydraidepbgo.IncrementFloat32Request\x1a&.hydraidepbgo.IncrementFloat32Response\"\x00\x12c\n" +
	"\x10IncrementFloat64\x12%.hydraidepbgo.IncrementFloat64Request\x1a&.hydraidepbgo.IncrementFloat64Response\"\x00BBZ@github.com/hydraide/hydraide/generated/hydraidepbgo;hydraidepbgob\x06proto3"

var (
	file_hydraide_proto_rawDescOnce sync.Once
	file_hydraide_proto_rawDescData []byte
)

func file_hydraide_proto_rawDescGZIP() []byte {
	file_hydraide_proto_rawDescOnce.Do(func() {
		file_hydraide_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_hydraide_proto_rawDesc), len(file_hydraide_proto_rawDesc)))
	})
	return file_hydraide_proto_rawDescData
}

var file_hydraide_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_hydraide_proto_msgTypes = make([]protoimpl.MessageInfo, 92)
var file_hydraide_proto_goTypes = []any{
	(SwampResponse_ErrCodeEnum)(0), // 0: hydraidepbgo.SwampResponse.ErrCodeEnum
	(Status_Code)(0),               // 1: hydraidepbgo.Status.Code
	(Boolean_Type)(0),              // 2: hydraidepbgo.Boolean.Type
	(IndexType_Type)(0),            // 3: hydraidepbgo.IndexType.Type
	(OrderType_Type)(0),            // 4: hydraidepbgo.OrderType.Type
	(DeleteResponse_SwampDeleteResponse_ErrorCodeEnum)(0), // 5: hydraidepbgo.DeleteResponse.SwampDeleteResponse.ErrorCodeEnum
	(Relational_Operator)(0),                              // 6: hydraidepbgo.Relational.Operator
	(*HeartbeatRequest)(nil),                              // 7: hydraidepbgo.HeartbeatRequest
	(*HeartbeatResponse)(nil),                             // 8: hydraidepbgo.HeartbeatResponse
	(*LockRequest)(nil),                                   // 9: hydraidepbgo.LockRequest
	(*LockResponse)(nil),                                  // 10: hydraidepbgo.LockResponse
	(*UnlockRequest)(nil),                                 // 11: hydraidepbgo.UnlockRequest
	(*UnlockResponse)(nil),                                // 12: hydraidepbgo.UnlockResponse
	(*DestroyRequest)(nil),                                // 13: hydraidepbgo.DestroyRequest
	(*DestroyResponse)(nil),                               // 14: hydraidepbgo.DestroyResponse
	(*SubscribeToInfoRequest)(nil),                        // 15: hydraidepbgo.SubscribeToInfoRequest
	(*SubscribeToInfoResponse)(nil),                       // 16: hydraidepbgo.SubscribeToInfoResponse
	(*SubscribeToEventsRequest)(nil),                      // 17: hydraidepbgo.SubscribeToEventsRequest
	(*SubscribeToEventsResponse)(nil),                     // 18: hydraidepbgo.SubscribeToEventsResponse
	(*SwampKeys)(nil),                                     // 19: hydraidepbgo.SwampKeys
	(*RegisterSwampRequest)(nil),                          // 20: hydraidepbgo.RegisterSwampRequest
	(*RegisterSwampResponse)(nil),                         // 21: hydraidepbgo.RegisterSwampResponse
	(*DeRegisterSwampRequest)(nil),                        // 22: hydraidepbgo.DeRegisterSwampRequest
	(*DeRegisterSwampResponse)(nil),                       // 23: hydraidepbgo.DeRegisterSwampResponse
	(*SetRequest)(nil),                                    // 24: hydraidepbgo.SetRequest
	(*SwampRequest)(nil),                                  // 25: hydraidepbgo.SwampRequest
	(*KeyValuePair)(nil),                                  // 26: hydraidepbgo.KeyValuePair
	(*SetResponse)(nil),                                   // 27: hydraidepbgo.SetResponse
	(*SwampResponse)(nil),                                 // 28: hydraidepbgo.SwampResponse
	(*KeyStatusPair)(nil),                                 // 29: hydraidepbgo.KeyStatusPair
	(*Status)(nil),                                        // 30: hydraidepbgo.Status
	(*GetRequest)(nil),                                    // 31: hydraidepbgo.GetRequest
	(*GetSwamp)(nil),                                      // 32: hydraidepbgo.GetSwamp
	(*GetResponse)(nil),                                   // 33: hydraidepbgo.GetResponse
	(*GetSwampResponse)(nil),                              // 34: hydraidepbgo.GetSwampResponse
	(*GetAllRequest)(nil),                                 // 35: hydraidepbgo.GetAllRequest
	(*GetAllResponse)(nil),                                // 36: hydraidepbgo.GetAllResponse
	(*ShiftExpiredTreasuresRequest)(nil),                  // 37: hydraidepbgo.ShiftExpiredTreasuresRequest
	(*ShiftExpiredTreasuresResponse)(nil),                 // 38: hydraidepbgo.ShiftExpiredTreasuresResponse
	(*Treasure)(nil),                                      // 39: hydraidepbgo.Treasure
	(*Boolean)(nil),                                       // 40: hydraidepbgo.Boolean
	(*GetByIndexRequest)(nil),                             // 41: hydraidepbgo.GetByIndexRequest
	(*IndexType)(nil),                                     // 42: hydraidepbgo.IndexType
	(*OrderType)(nil),                                     // 43: hydraidepbgo.OrderType
	(*GetByIndexResponse)(nil),                            // 44: hydraidepbgo.GetByIndexResponse
	(*DeleteRequest)(nil),                                 // 45: hydraidepbgo.DeleteRequest
	(*DeleteResponse)(nil),                                // 46: hydraidepbgo.DeleteResponse
	(*CountRequest)(nil),                                  // 47: hydraidepbgo.CountRequest
	(*CountResponse)(nil),                                 // 48: hydraidepbgo.CountResponse
	(*CountSwamp)(nil),                                    // 49: hydraidepbgo.CountSwamp
	(*IncrementRequestMetadata)(nil),                      // 50: hydraidepbgo.IncrementRequestMetadata
	(*IncrementResponseMetadata)(nil),                     // 51: hydraidepbgo.IncrementResponseMetadata
	(*IncrementInt8Request)(nil),                          // 52: hydraidepbgo.IncrementInt8Request
	(*IncrementInt8Condition)(nil),                        // 53: hydraidepbgo.IncrementInt8Condition
	(*IncrementInt8Response)(nil),                         // 54: hydraidepbgo.IncrementInt8Response
	(*IncrementInt16Request)(nil),                         // 55: hydraidepbgo.IncrementInt16Request
	(*IncrementInt16Condition)(nil),                       // 56: hydraidepbgo.IncrementInt16Condition
	(*IncrementInt16Response)(nil),                        // 57: hydraidepbgo.IncrementInt16Response
	(*IncrementInt32Request)(nil),                         // 58: hydraidepbgo.IncrementInt32Request
	(*IncrementInt32Condition)(nil),                       // 59: hydraidepbgo.IncrementInt32Condition
	(*IncrementInt32Response)(nil),                        // 60: hydraidepbgo.IncrementInt32Response
	(*IncrementInt64Request)(nil),                         // 61: hydraidepbgo.IncrementInt64Request
	(*IncrementInt64Condition)(nil),                       // 62: hydraidepbgo.IncrementInt64Condition
	(*IncrementInt64Response)(nil),                        // 63: hydraidepbgo.IncrementInt64Response
	(*IncrementUint8Request)(nil),                         // 64: hydraidepbgo.IncrementUint8Request
	(*IncrementUint8Condition)(nil),                       // 65: hydraidepbgo.IncrementUint8Condition
	(*IncrementUint8Response)(nil),                        // 66: hydraidepbgo.IncrementUint8Response
	(*IncrementUint16Request)(nil),                        // 67: hydraidepbgo.IncrementUint16Request
	(*IncrementUint16Condition)(nil),                      // 68: hydraidepbgo.IncrementUint16Condition
	(*IncrementUint16Response)(nil),                       // 69: hydraidepbgo.IncrementUint16Response
	(*IncrementUint32Request)(nil),                        // 70: hydraidepbgo.IncrementUint32Request
	(*IncrementUint32Condition)(nil),                      // 71: hydraidepbgo.IncrementUint32Condition
	(*IncrementUint32Response)(nil),                       // 72: hydraidepbgo.IncrementUint32Response
	(*IncrementUint64Request)(nil),                        // 73: hydraidepbgo.IncrementUint64Request
	(*IncrementUint64Condition)(nil),                      // 74: hydraidepbgo.IncrementUint64Condition
	(*IncrementUint64Response)(nil),                       // 75: hydraidepbgo.IncrementUint64Response
	(*Relational)(nil),                                    // 76: hydraidepbgo.Relational
	(*IncrementFloat32Request)(nil),                       // 77: hydraidepbgo.IncrementFloat32Request
	(*IncrementFloat32Condition)(nil),                     // 78: hydraidepbgo.IncrementFloat32Condition
	(*IncrementFloat32Response)(nil),                      // 79: hydraidepbgo.IncrementFloat32Response
	(*IncrementFloat64Request)(nil),                       // 80: hydraidepbgo.IncrementFloat64Request
	(*IncrementFloat64Condition)(nil),                     // 81: hydraidepbgo.IncrementFloat64Condition
	(*IncrementFloat64Response)(nil),                      // 82: hydraidepbgo.IncrementFloat64Response
	(*KeySlicePair)(nil),                                  // 83: hydraidepbgo.KeySlicePair
	(*AddToUint32SlicePushRequest)(nil),                   // 84: hydraidepbgo.AddToUint32SlicePushRequest
	(*AddToUint32SlicePushResponse)(nil),                  // 85: hydraidepbgo.AddToUint32SlicePushResponse
	(*Uint32SliceDeleteRequest)(nil),                      // 86: hydraidepbgo.Uint32SliceDeleteRequest
	(*Uint32SliceDeleteResponse)(nil),                     // 87: hydraidepbgo.Uint32SliceDeleteResponse
	(*Uint32SliceSizeRequest)(nil),                        // 88: hydraidepbgo.Uint32SliceSizeRequest
	(*Uint32SliceSizeResponse)(nil),                       // 89: hydraidepbgo.Uint32SliceSizeResponse
	(*Uint32SliceIsValueExistRequest)(nil),                // 90: hydraidepbgo.Uint32SliceIsValueExistRequest
	(*Uint32SliceIsValueExistResponse)(nil),               // 91: hydraidepbgo.Uint32SliceIsValueExistResponse
	(*IsSwampExistRequest)(nil),                           // 92: hydraidepbgo.IsSwampExistRequest
	(*IsSwampExistResponse)(nil),                          // 93: hydraidepbgo.IsSwampExistResponse
	(*IsKeyExistRequest)(nil),                             // 94: hydraidepbgo.IsKeyExistRequest
	(*IsKeyExistResponse)(nil),                            // 95: hydraidepbgo.IsKeyExistResponse
	(*DeleteRequest_SwampKeys)(nil),                       // 96: hydraidepbgo.DeleteRequest.SwampKeys
	(*DeleteResponse_SwampDeleteResponse)(nil),            // 97: hydraidepbgo.DeleteResponse.SwampDeleteResponse
	(*CountRequest_SwampIdentifier)(nil),                  // 98: hydraidepbgo.CountRequest.SwampIdentifier
	(*timestamppb.Timestamp)(nil),                         // 99: google.protobuf.Timestamp
}
var file_hydraide_proto_depIdxs = []int32{
	39,  // 0: hydraidepbgo.SubscribeToEventsResponse.Treasure:type_name -> hydraidepbgo.Treasure
	39,  // 1: hydraidepbgo.SubscribeToEventsResponse.OldTreasure:type_name -> hydraidepbgo.Treasure
	39,  // 2: hydraidepbgo.SubscribeToEventsResponse.DeletedTreasure:type_name -> hydraidepbgo.Treasure
	99,  // 3: hydraidepbgo.SubscribeToEventsResponse.EventTime:type_name -> google.protobuf.Timestamp
	1,   // 4: hydraidepbgo.SubscribeToEventsResponse.Status:type_name -> hydraidepbgo.Status.Code
	25,  // 5: hydraidepbgo.SetRequest.Swamps:type_name -> hydraidepbgo.SwampRequest
	26,  // 6: hydraidepbgo.SwampRequest.KeyValues:type_name -> hydraidepbgo.KeyValuePair
	2,   // 7: hydraidepbgo.KeyValuePair.BoolVal:type_name -> hydraidepbgo.Boolean.Type
	99,  // 8: hydraidepbgo.KeyValuePair.CreatedAt:type_name -> google.protobuf.Timestamp
	99,  // 9: hydraidepbgo.KeyValuePair.UpdatedAt:type_name -> google.protobuf.Timestamp
	99,  // 10: hydraidepbgo.KeyValuePair.ExpiredAt:type_name -> google.protobuf.Timestamp
	28,  // 11: hydraidepbgo.SetResponse.Swamps:type_name -> hydraidepbgo.SwampResponse
	29,  // 12: hydraidepbgo.SwampResponse.KeysAndStatuses:type_name -> hydraidepbgo.KeyStatusPair
	0,   // 13: hydraidepbgo.SwampResponse.ErrorCode:type_name -> hydraidepbgo.SwampResponse.ErrCodeEnum
	1,   // 14: hydraidepbgo.KeyStatusPair.Status:type_name -> hydraidepbgo.Status.Code
	32,  // 15: hydraidepbgo.GetRequest.Swamps:type_name -> hydraidepbgo.GetSwamp
	34,  // 16: hydraidepbgo.GetResponse.Swamps:type_name -> hydraidepbgo.GetSwampResponse
	39,  // 17: hydraidepbgo.GetSwampResponse.Treasures:type_name -> hydraidepbgo.Treasure
	39,  // 18: hydraidepbgo.GetAllResponse.Treasures:type_name -> hydraidepbgo.Treasure
	39,  // 19: hydraidepbgo.ShiftExpiredTreasuresResponse.Treasures:type_name -> hydraidepbgo.Treasure
	2,   // 20: hydraidepbgo.Treasure.BoolVal:type_name -> hydraidepbgo.Boolean.Type
	99,  // 21: hydraidepbgo.Treasure.CreatedAt:type_name -> google.protobuf.Timestamp
	99,  // 22: hydraidepbgo.Treasure.UpdatedAt:type_name -> google.protobuf.Timestamp
	99,  // 23: hydraidepbgo.Treasure.ExpiredAt:type_name -> google.protobuf.Timestamp
	3,   // 24: hydraidepbgo.GetByIndexRequest.IndexType:type_name -> hydraidepbgo.IndexType.Type
	4,   // 25: hydraidepbgo.GetByIndexRequest.OrderType:type_name -> hydraidepbgo.OrderType.Type
	39,  // 26: hydraidepbgo.GetByIndexResponse.Treasures:type_name -> hydraidepbgo.Treasure
	96,  // 27: hydraidepbgo.DeleteRequest.Swamps:type_name -> hydraidepbgo.DeleteRequest.SwampKeys
	97,  // 28: hydraidepbgo.DeleteResponse.Responses:type_name -> hydraidepbgo.DeleteResponse.SwampDeleteResponse
	98,  // 29: hydraidepbgo.CountRequest.Swamps:type_name -> hydraidepbgo.CountRequest.SwampIdentifier
	49,  // 30: hydraidepbgo.CountResponse.Swamps:type_name -> hydraidepbgo.CountSwamp
	99,  // 31: hydraidepbgo.IncrementRequestMetadata.ExpiredAt:type_name -> google.protobuf.Timestamp
	99,  // 32: hydraidepbgo.IncrementResponseMetadata.CreatedAt:type_name -> google.protobuf.Timestamp
	99,  // 33: hydraidepbgo.IncrementResponseMetadata.UpdatedAt:type_name -> google.protobuf.Timestamp
	99,  // 34: hydraidepbgo.IncrementResponseMetadata.ExpiredAt:type_name -> google.protobuf.Timestamp
	53,  // 35: hydraidepbgo.IncrementInt8Request.Condition:type_name -> hydraidepbgo.IncrementInt8Condition
	50,  // 36: hydraidepbgo.IncrementInt8Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 37: hydraidepbgo.IncrementInt8Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 38: hydraidepbgo.IncrementInt8Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 39: hydraidepbgo.IncrementInt8Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	56,  // 40: hydraidepbgo.IncrementInt16Request.Condition:type_name -> hydraidepbgo.IncrementInt16Condition
	50,  // 41: hydraidepbgo.IncrementInt16Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 42: hydraidepbgo.IncrementInt16Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 43: hydraidepbgo.IncrementInt16Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 44: hydraidepbgo.IncrementInt16Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	59,  // 45: hydraidepbgo.IncrementInt32Request.Condition:type_name -> hydraidepbgo.IncrementInt32Condition
	50,  // 46: hydraidepbgo.IncrementInt32Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 47: hydraidepbgo.IncrementInt32Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 48: hydraidepbgo.IncrementInt32Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 49: hydraidepbgo.IncrementInt32Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	62,  // 50: hydraidepbgo.IncrementInt64Request.Condition:type_name -> hydraidepbgo.IncrementInt64Condition
	50,  // 51: hydraidepbgo.IncrementInt64Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 52: hydraidepbgo.IncrementInt64Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 53: hydraidepbgo.IncrementInt64Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 54: hydraidepbgo.IncrementInt64Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	65,  // 55: hydraidepbgo.IncrementUint8Request.Condition:type_name -> hydraidepbgo.IncrementUint8Condition
	50,  // 56: hydraidepbgo.IncrementUint8Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 57: hydraidepbgo.IncrementUint8Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 58: hydraidepbgo.IncrementUint8Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 59: hydraidepbgo.IncrementUint8Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	68,  // 60: hydraidepbgo.IncrementUint16Request.Condition:type_name -> hydraidepbgo.IncrementUint16Condition
	50,  // 61: hydraidepbgo.IncrementUint16Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 62: hydraidepbgo.IncrementUint16Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 63: hydraidepbgo.IncrementUint16Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 64: hydraidepbgo.IncrementUint16Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	71,  // 65: hydraidepbgo.IncrementUint32Request.Condition:type_name -> hydraidepbgo.IncrementUint32Condition
	50,  // 66: hydraidepbgo.IncrementUint32Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 67: hydraidepbgo.IncrementUint32Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 68: hydraidepbgo.IncrementUint32Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 69: hydraidepbgo.IncrementUint32Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	74,  // 70: hydraidepbgo.IncrementUint64Request.Condition:type_name -> hydraidepbgo.IncrementUint64Condition
	50,  // 71: hydraidepbgo.IncrementUint64Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 72: hydraidepbgo.IncrementUint64Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 73: hydraidepbgo.IncrementUint64Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 74: hydraidepbgo.IncrementUint64Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	78,  // 75: hydraidepbgo.IncrementFloat32Request.Condition:type_name -> hydraidepbgo.IncrementFloat32Condition
	50,  // 76: hydraidepbgo.IncrementFloat32Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 77: hydraidepbgo.IncrementFloat32Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 78: hydraidepbgo.IncrementFloat32Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 79: hydraidepbgo.IncrementFloat32Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	81,  // 80: hydraidepbgo.IncrementFloat64Request.Condition:type_name -> hydraidepbgo.IncrementFloat64Condition
	50,  // 81: hydraidepbgo.IncrementFloat64Request.SetIfNotExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	50,  // 82: hydraidepbgo.IncrementFloat64Request.SetIfExist:type_name -> hydraidepbgo.IncrementRequestMetadata
	6,   // 83: hydraidepbgo.IncrementFloat64Condition.RelationalOperator:type_name -> hydraidepbgo.Relational.Operator
	51,  // 84: hydraidepbgo.IncrementFloat64Response.Metadata:type_name -> hydraidepbgo.IncrementResponseMetadata
	83,  // 85: hydraidepbgo.AddToUint32SlicePushRequest.KeySlicePairs:type_name -> hydraidepbgo.KeySlicePair
	83,  // 86: hydraidepbgo.Uint32SliceDeleteRequest.KeySlicePairs:type_name -> hydraidepbgo.KeySlicePair
	5,   // 87: hydraidepbgo.DeleteResponse.SwampDeleteResponse.ErrorCode:type_name -> hydraidepbgo.DeleteResponse.SwampDeleteResponse.ErrorCodeEnum
	29,  // 88: hydraidepbgo.DeleteResponse.SwampDeleteResponse.KeyStatuses:type_name -> hydraidepbgo.KeyStatusPair
	7,   // 89: hydraidepbgo.HydraideService.Heartbeat:input_type -> hydraidepbgo.HeartbeatRequest
	9,   // 90: hydraidepbgo.HydraideService.Lock:input_type -> hydraidepbgo.LockRequest
	11,  // 91: hydraidepbgo.HydraideService.Unlock:input_type -> hydraidepbgo.UnlockRequest
	20,  // 92: hydraidepbgo.HydraideService.RegisterSwamp:input_type -> hydraidepbgo.RegisterSwampRequest
	22,  // 93: hydraidepbgo.HydraideService.DeRegisterSwamp:input_type -> hydraidepbgo.DeRegisterSwampRequest
	24,  // 94: hydraidepbgo.HydraideService.Set:input_type -> hydraidepbgo.SetRequest
	31,  // 95: hydraidepbgo.HydraideService.Get:input_type -> hydraidepbgo.GetRequest
	35,  // 96: hydraidepbgo.HydraideService.GetAll:input_type -> hydraidepbgo.GetAllRequest
	41,  // 97: hydraidepbgo.HydraideService.GetByIndex:input_type -> hydraidepbgo.GetByIndexRequest
	37,  // 98: hydraidepbgo.HydraideService.ShiftExpiredTreasures:input_type -> hydraidepbgo.ShiftExpiredTreasuresRequest
	13,  // 99: hydraidepbgo.HydraideService.Destroy:input_type -> hydraidepbgo.DestroyRequest
	45,  // 100: hydraidepbgo.HydraideService.Delete:input_type -> hydraidepbgo.DeleteRequest
	47,  // 101: hydraidepbgo.HydraideService.Count:input_type -> hydraidepbgo.CountRequest
	92,  // 102: hydraidepbgo.HydraideService.IsSwampExist:input_type -> hydraidepbgo.IsSwampExistRequest
	94,  // 103: hydraidepbgo.HydraideService.IsKeyExist:input_type -> hydraidepbgo.IsKeyExistRequest
	17,  // 104: hydraidepbgo.HydraideService.SubscribeToEvents:input_type -> hydraidepbgo.SubscribeToEventsRequest
	15,  // 105: hydraidepbgo.HydraideService.SubscribeToInfo:input_type -> hydraidepbgo.SubscribeToInfoRequest
	84,  // 106: hydraidepbgo.HydraideService.Uint32SlicePush:input_type -> hydraidepbgo.AddToUint32SlicePushRequest
	86,  // 107: hydraidepbgo.HydraideService.Uint32SliceDelete:input_type -> hydraidepbgo.Uint32SliceDeleteRequest
	88,  // 108: hydraidepbgo.HydraideService.Uint32SliceSize:input_type -> hydraidepbgo.Uint32SliceSizeRequest
	90,  // 109: hydraidepbgo.HydraideService.Uint32SliceIsValueExist:input_type -> hydraidepbgo.Uint32SliceIsValueExistRequest
	52,  // 110: hydraidepbgo.HydraideService.IncrementInt8:input_type -> hydraidepbgo.IncrementInt8Request
	55,  // 111: hydraidepbgo.HydraideService.IncrementInt16:input_type -> hydraidepbgo.IncrementInt16Request
	58,  // 112: hydraidepbgo.HydraideService.IncrementInt32:input_type -> hydraidepbgo.IncrementInt32Request
	61,  // 113: hydraidepbgo.HydraideService.IncrementInt64:input_type -> hydraidepbgo.IncrementInt64Request
	64,  // 114: hydraidepbgo.HydraideService.IncrementUint8:input_type -> hydraidepbgo.IncrementUint8Request
	67,  // 115: hydraidepbgo.HydraideService.IncrementUint16:input_type -> hydraidepbgo.IncrementUint16Request
	70,  // 116: hydraidepbgo.HydraideService.IncrementUint32:input_type -> hydraidepbgo.IncrementUint32Request
	73,  // 117: hydraidepbgo.HydraideService.IncrementUint64:input_type -> hydraidepbgo.IncrementUint64Request
	77,  // 118: hydraidepbgo.HydraideService.IncrementFloat32:input_type -> hydraidepbgo.IncrementFloat32Request
	80,  // 119: hydraidepbgo.HydraideService.IncrementFloat64:input_type -> hydraidepbgo.IncrementFloat64Request
	8,   // 120: hydraidepbgo.HydraideService.Heartbeat:output_type -> hydraidepbgo.HeartbeatResponse
	10,  // 121: hydraidepbgo.HydraideService.Lock:output_type -> hydraidepbgo.LockResponse
	12,  // 122: hydraidepbgo.HydraideService.Unlock:output_type -> hydraidepbgo.UnlockResponse
	21,  // 123: hydraidepbgo.HydraideService.RegisterSwamp:output_type -> hydraidepbgo.RegisterSwampResponse
	23,  // 124: hydraidepbgo.HydraideService.DeRegisterSwamp:output_type -> hydraidepbgo.DeRegisterSwampResponse
	27,  // 125: hydraidepbgo.HydraideService.Set:output_type -> hydraidepbgo.SetResponse
	33,  // 126: hydraidepbgo.HydraideService.Get:output_type -> hydraidepbgo.GetResponse
	36,  // 127: hydraidepbgo.HydraideService.GetAll:output_type -> hydraidepbgo.GetAllResponse
	44,  // 128: hydraidepbgo.HydraideService.GetByIndex:output_type -> hydraidepbgo.GetByIndexResponse
	38,  // 129: hydraidepbgo.HydraideService.ShiftExpiredTreasures:output_type -> hydraidepbgo.ShiftExpiredTreasuresResponse
	14,  // 130: hydraidepbgo.HydraideService.Destroy:output_type -> hydraidepbgo.DestroyResponse
	46,  // 131: hydraidepbgo.HydraideService.Delete:output_type -> hydraidepbgo.DeleteResponse
	48,  // 132: hydraidepbgo.HydraideService.Count:output_type -> hydraidepbgo.CountResponse
	93,  // 133: hydraidepbgo.HydraideService.IsSwampExist:output_type -> hydraidepbgo.IsSwampExistResponse
	95,  // 134: hydraidepbgo.HydraideService.IsKeyExist:output_type -> hydraidepbgo.IsKeyExistResponse
	18,  // 135: hydraidepbgo.HydraideService.SubscribeToEvents:output_type -> hydraidepbgo.SubscribeToEventsResponse
	16,  // 136: hydraidepbgo.HydraideService.SubscribeToInfo:output_type -> hydraidepbgo.SubscribeToInfoResponse
	85,  // 137: hydraidepbgo.HydraideService.Uint32SlicePush:output_type -> hydraidepbgo.AddToUint32SlicePushResponse
	87,  // 138: hydraidepbgo.HydraideService.Uint32SliceDelete:output_type -> hydraidepbgo.Uint32SliceDeleteResponse
	89,  // 139: hydraidepbgo.HydraideService.Uint32SliceSize:output_type -> hydraidepbgo.Uint32SliceSizeResponse
	91,  // 140: hydraidepbgo.HydraideService.Uint32SliceIsValueExist:output_type -> hydraidepbgo.Uint32SliceIsValueExistResponse
	54,  // 141: hydraidepbgo.HydraideService.IncrementInt8:output_type -> hydraidepbgo.IncrementInt8Response
	57,  // 142: hydraidepbgo.HydraideService.IncrementInt16:output_type -> hydraidepbgo.IncrementInt16Response
	60,  // 143: hydraidepbgo.HydraideService.IncrementInt32:output_type -> hydraidepbgo.IncrementInt32Response
	63,  // 144: hydraidepbgo.HydraideService.IncrementInt64:output_type -> hydraidepbgo.IncrementInt64Response
	66,  // 145: hydraidepbgo.HydraideService.IncrementUint8:output_type -> hydraidepbgo.IncrementUint8Response
	69,  // 146: hydraidepbgo.HydraideService.IncrementUint16:output_type -> hydraidepbgo.IncrementUint16Response
	72,  // 147: hydraidepbgo.HydraideService.IncrementUint32:output_type -> hydraidepbgo.IncrementUint32Response
	75,  // 148: hydraidepbgo.HydraideService.IncrementUint64:output_type -> hydraidepbgo.IncrementUint64Response
	79,  // 149: hydraidepbgo.HydraideService.IncrementFloat32:output_type -> hydraidepbgo.IncrementFloat32Response
	82,  // 150: hydraidepbgo.HydraideService.IncrementFloat64:output_type -> hydraidepbgo.IncrementFloat64Response
	120, // [120:151] is the sub-list for method output_type
	89,  // [89:120] is the sub-list for method input_type
	89,  // [89:89] is the sub-list for extension type_name
	89,  // [89:89] is the sub-list for extension extendee
	0,   // [0:89] is the sub-list for field type_name
}

func init() { file_hydraide_proto_init() }
func file_hydraide_proto_init() {
	if File_hydraide_proto != nil {
		return
	}
	file_hydraide_proto_msgTypes[13].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[19].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[21].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[32].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[43].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[44].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[45].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[48].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[51].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[54].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[57].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[60].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[63].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[66].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[70].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[73].OneofWrappers = []any{}
	file_hydraide_proto_msgTypes[90].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_hydraide_proto_rawDesc), len(file_hydraide_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   92,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_hydraide_proto_goTypes,
		DependencyIndexes: file_hydraide_proto_depIdxs,
		EnumInfos:         file_hydraide_proto_enumTypes,
		MessageInfos:      file_hydraide_proto_msgTypes,
	}.Build()
	File_hydraide_proto = out.File
	file_hydraide_proto_goTypes = nil
	file_hydraide_proto_depIdxs = nil
}
